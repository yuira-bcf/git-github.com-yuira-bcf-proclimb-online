<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>教材：じゃんけん（継承＋abstract＋interface＋ポリモーフィズム版）</title>
  <style>
    :root{
      --bg:#ffffff; --panel:#f8fafc; --text:#0f172a; --muted:#475569;
      --accent:#2563eb; --border:#e2e8f0; --codebg:#f1f5f9; --good:#16a34a; --warn:#d97706;
    }
    body{ margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic",sans-serif;
      background:var(--bg); color:var(--text); line-height:1.7; }
    header{ padding:26px 18px; border-bottom:1px solid var(--border);
      background:rgba(248,250,252,0.9); backdrop-filter:blur(6px); position:sticky; top:0; z-index:10; }
    header h1{ font-size:18px; margin:0 0 6px 0; letter-spacing:.02em; }
    header p{ margin:0; color:var(--muted); font-size:13px; }
    main{ max-width:980px; margin:0 auto; padding:20px 18px 60px; }
    nav{ margin:16px 0 22px; display:flex; flex-wrap:wrap; gap:10px; }
    nav a{ color:var(--text); text-decoration:none; border:1px solid var(--border);
      padding:8px 10px; border-radius:10px; background:var(--panel); font-size:13px; }
    nav a:hover{ border-color:rgba(37,99,235,0.5); box-shadow:0 0 0 3px rgba(37,99,235,0.12); }
    section{ background:var(--panel); border:1px solid var(--border); border-radius:14px;
      padding:18px 16px; margin:14px 0; }
    section h2{ margin:0 0 10px 0; font-size:16px; }
    h3{ margin:14px 0 8px; font-size:14px; }
    .badge{ display:inline-block; font-size:12px; padding:3px 8px; border-radius:999px; border:1px solid var(--border);
      color:var(--muted); margin-left:8px; vertical-align:middle; }
    ul,ol{ margin:10px 0 0 18px; }
    li{ margin:6px 0; }
    .callout{ border-left:4px solid var(--accent); padding:10px 12px; background:rgba(37,99,235,0.08);
      border-radius:10px; margin:12px 0; }
    .callout small{ color:var(--muted); }
    pre{ margin:12px 0 0; padding:12px 12px; border-radius:12px; overflow:auto;
      background:var(--codebg); border:1px solid var(--border); }
    code{ font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      font-size:12.5px; color:#0f172a; }
    .meta{ color:var(--muted); font-size:13px; }
    .ok{ color:var(--good); font-weight:700; }
    .warn{ color:var(--warn); font-weight:700; }
    footer{ max-width:980px; margin:0 auto; padding:18px; color:var(--muted); font-size:12px; }
  </style>
</head>

<body>
<header>
  <h1>教材：じゃんけん（継承＋abstract＋interface＋ポリモーフィズム版）
    <span class="badge">interface</span><span class="badge">abstract</span><span class="badge">polymorphism</span>
  </h1>
  <p>「同じ呼び出しなのに、相手によって中身が変わる」を体験する版。ここからがOOPの本番です。</p>
</header>

<main>
  <nav>
    <a href="#overview">アプリ概要</a>
    <a href="#howto">コーディングの進め方</a>
    <a href="#impl">実装用ソース</a>
    <a href="#answer">回答プログラム</a>
    <a href="#explain">プログラム解説</a>
  </nav>

  <section id="overview">
    <h2>アプリ概要 <span class="badge">コンソール</span></h2>
    <p>
      標準入力で <strong>G/C/P/Q</strong> を受け取り、CPUとじゃんけんを行うアプリです。<br />
      今回は、前回までの「ベタ書き」や「共有だけ継承」から進んで、
      <strong>interface + abstract + 継承 + オーバーライド</strong>で<strong>ポリモーフィズム</strong>を使います。
    </p>

    <ul>
      <li><strong>入力</strong>：G=グー / C=チョキ / P=パー / Q=終了</li>
      <li><strong>手の表現</strong>：int（0=グー / 1=チョキ / 2=パー、-1=終了）</li>
      <li><strong>CPU</strong>：Randomで0〜2を生成</li>
      <li><strong>勝敗</strong>：勝ち / 負け / 引き分け を表示</li>
    </ul>

    <div class="callout">
      <div><span class="ok">今回のゴール：</span>Game側が「人かCPUか」を知らなくても動く設計にする</div>
      <small>Gameは Player（インターフェース）しか見ない。中身は知らない。知らないけど動く。これが強い。</small>
    </div>

    <p class="meta">
      クラス構成（この教材の主役）：
      <br />
      <strong>interface</strong>：Player（契約：getName/nextHand/handLabel）
      <br />
      <strong>abstract class</strong>：AbstractPlayer（共通実装：name/getName/handLabel）
      <br />
      <strong>concrete class</strong>：HumanPlayer / CpuPlayer（nextHandをオーバーライド）
      <br />
      <strong>Game</strong>：JankenGame（Player型で受け取ってプレイする＝ポリモーフィズム発動）
    </p>
  </section>

  <section id="howto">
    <h2>コーディングの進め方</h2>

    <ol>
      <li><strong>Player（interface）</strong> を作る：Gameが依存する「約束」を先に確定。</li>
      <li><strong>AbstractPlayer（abstract class）</strong> を作る：共通実装（名前・表示）を置く。</li>
      <li><strong>HumanPlayer / CpuPlayer</strong> を作る：<code>nextHand()</code> をオーバーライド（ここで振る舞いが分岐）。</li>
      <li><strong>JankenGame</strong> を作る：<code>Player</code> 型のままプレイできるように組む（instanceof禁止）。</li>
      <li><strong>Main</strong> で組み立てて実行：<code>new HumanPlayer</code> と <code>new CpuPlayer</code> を <code>Player</code> として扱う。</li>
    </ol>

    <div class="callout">
      <div><strong>やってはいけない（教材の意図が死ぬ）</strong></div>
      <ul>
        <li><code>if (player instanceof HumanPlayer)</code> で分岐する（それ、OOPじゃなくて型当てクイズ）</li>
        <li>GameにScanner/Randomを持たせる（責務が混ざる）</li>
      </ul>
      <small>「ポリモーフィズムを使う」＝「分岐をクラス側に押し込む」。分岐をGameに残すと、結局ベタ書きです。</small>
    </div>

    <p class="meta">
      実行（例）：<br />
      <code>javac Main.java</code><br />
      <code>java Main</code>
    </p>
  </section>

  <section id="impl">
    <h2>実装用ソース（生徒用：穴埋め版）</h2>
    <p class="meta">
      ここは「答えを載せない」版です。TODOコメントの指示に従って実装してください。<br />
      ※最初はコンパイルできるように、最低限のダミー実装を入れています（必ず置き換えること）。
    </p>

<pre><code>// Main.java（OOP版：穴埋め）
import java.util.Random;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {

        // =========================================================
        // 1) 準備
        // =========================================================
        // TODO: Scanner を作成
        // TODO: Random を作成
        //
        // TODO: Player you を作成（実体は HumanPlayer）
        //   ・名前は "あなた"
        //   ・scanner を渡す
        //
        // TODO: Player cpu を作成（実体は CpuPlayer）
        //   ・名前は "CPU"
        //   ・random を渡す
        //
        // TODO: JankenGame game を作成して run() を呼ぶ
        //   ・game は Player 型だけ知っていれば動くのが理想


        // TODO: 終了時に scanner.close()

    }
}

// =========================================================
// interface：Player（Gameが依存する「約束」）
// =========================================================
interface Player {
    // TODO: getName() を宣言
    // TODO: nextHand() を宣言（0/1/2、終了は -1 を返す設計）
    // TODO: handLabel(int hand) を宣言（0/1/2 → 表示用文字列）
}

// =========================================================
// abstract class：AbstractPlayer（共通実装をまとめる）
// =========================================================
abstract class AbstractPlayer implements Player {

    // TODO: name フィールド（private final String）

    // TODO: コンストラクタ AbstractPlayer(String name)
    //   ・this.name = name;

    // TODO: getName() を実装（nameを返す）

    // TODO: handLabel(int hand) を実装
    //   ・0→"グー" / 1→"チョキ" / 2→"パー" / それ以外→"?"

    // nextHand() は「具体クラスで実装させる」ため abstract のままにする

    // --- ダミー（コンパイル用）※必ず置き換える ---
    public String getName(){ return ""; }
    public String handLabel(int hand){ return ""; }
}

// =========================================================
// concrete：HumanPlayer（入力で手を決める）
// =========================================================
class HumanPlayer extends AbstractPlayer {

    // TODO: Scanner scanner フィールド（private final）

    // TODO: コンストラクタ HumanPlayer(String name, Scanner scanner)
    //   ・super(name)
    //   ・this.scanner = scanner

    // TODO: nextHand() をオーバーライド
    //   ・プロンプトを表示（例：「あなたの手(G/C/P) 終了(Q)：」）
    //   ・scanner.nextLine() で入力
    //   ・空入力なら注意してやり直し
    //   ・先頭1文字を取り出して大文字化（substring + toUpperCase）
    //   ・"Q" なら -1 を返す
    //   ・"G"→0 / "C"→1 / "P"→2
    //   ・それ以外は注意してやり直し（Game側に不正値を渡さない）

    // --- ダミー（コンパイル用）※必ず置き換える ---
    public HumanPlayer(String name, Scanner scanner){ super(name); }
    public int nextHand(){ return -1; }
}

// =========================================================
// concrete：CpuPlayer（乱数で手を決める）
// =========================================================
class CpuPlayer extends AbstractPlayer {

    // TODO: Random random フィールド（private final）

    // TODO: コンストラクタ CpuPlayer(String name, Random random)
    //   ・super(name)
    //   ・this.random = random

    // TODO: nextHand() をオーバーライド
    //   ・random.nextInt(3) を返す（0〜2）

    // --- ダミー（コンパイル用）※必ず置き換える ---
    public CpuPlayer(String name, Random random){ super(name); }
    public int nextHand(){ return 0; }
}

// =========================================================
// Game：JankenGame（Playerだけ見て進行する）
// =========================================================
class JankenGame {

    // TODO: Player you, Player cpu フィールド（private final）

    // TODO: コンストラクタ（Player you, Player cpu）

    // TODO: run() を実装
    //   ・タイトル表示、入力説明
    //   ・ループ
    //     - int youHand = you.nextHand()
    //     - youHand == -1 なら終了メッセージを出して break
    //     - int cpuHand = cpu.nextHand()
    //     - you.getName() と you.handLabel(youHand) で表示
    //     - cpu.getName() と cpu.handLabel(cpuHand) で表示
    //     - 勝敗判定して表示（勝ちの3条件＋引き分け）

    // --- ダミー（コンパイル用）※必ず置き換える ---
    public JankenGame(Player you, Player cpu){}
    public void run(){}
}</code></pre>
  </section>

  <section id="answer">
    <h2>回答プログラム（先生用：完成版）</h2>
    <p class="meta">下記が完成版です。答え合わせ／解説用に使用してください。</p>

<pre><code>// Main.java（OOP版：完成）
import java.util.Random;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);
        Random random = new Random();

        // interface型（Player）で受ける：ここから既にポリモーフィズムの準備
        Player you = new HumanPlayer("あなた", scanner);
        Player cpu = new CpuPlayer("CPU", random);

        JankenGame game = new JankenGame(you, cpu);
        game.run();

        scanner.close();
    }
}

interface Player {
    String getName();
    int nextHand();              // 0/1/2、終了は -1
    String handLabel(int hand);  // 表示用
}

abstract class AbstractPlayer implements Player {
    private final String name;

    protected AbstractPlayer(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public String handLabel(int hand) {
        if (hand == 0) return "グー";
        if (hand == 1) return "チョキ";
        if (hand == 2) return "パー";
        return "?";
    }

    // nextHand() は抽象：具体クラスに実装を強制する
    public abstract int nextHand();
}

class HumanPlayer extends AbstractPlayer {
    private final Scanner scanner;

    public HumanPlayer(String name, Scanner scanner) {
        super(name);
        this.scanner = scanner;
    }

    // ここが「同じ nextHand() でも、中身が違う」＝ポリモーフィズムの材料
    @Override
    public int nextHand() {
        while (true) {
            System.out.print(getName() + "の手(G=グー/C=チョキ/P=パー) 終了(Q)：");
            String input = scanner.nextLine();

            if (input == null || input.length() == 0) {
                System.out.println("入力がありません。");
                continue;
            }

            String cmd = input.substring(0, 1);
            cmd = cmd.toUpperCase();

            if (cmd.equals("Q")) return -1;
            if (cmd.equals("G")) return 0;
            if (cmd.equals("C")) return 1;
            if (cmd.equals("P")) return 2;

            System.out.println("不正な入力です。G/C/P/Q のいずれかを入力してください。");
        }
    }
}

class CpuPlayer extends AbstractPlayer {
    private final Random random;

    public CpuPlayer(String name, Random random) {
        super(name);
        this.random = random;
    }

    @Override
    public int nextHand() {
        return random.nextInt(3);
    }
}

class JankenGame {
    private final Player you;
    private final Player cpu;

    public JankenGame(Player you, Player cpu) {
        this.you = you;
        this.cpu = cpu;
    }

    public void run() {
        System.out.println("=== じゃんけん（OOP版）===");
        System.out.println("入力：G=グー / C=チョキ / P=パー / Q=終了");
        System.out.println();

        while (true) {
            int youHand = you.nextHand(); // ← Player型の同一呼び出し
            if (youHand == -1) {
                System.out.println("ゲームを終了します。");
                break;
            }

            int cpuHand = cpu.nextHand(); // ← Player型の同一呼び出し

            System.out.println(you.getName() + "： " + you.handLabel(youHand));
            System.out.println(cpu.getName() + "： " + cpu.handLabel(cpuHand));

            if (youHand == cpuHand) {
                System.out.println("結果：引き分け");
            } else if (
                    (youHand == 0 &amp;&amp; cpuHand == 1) ||
                    (youHand == 1 &amp;&amp; cpuHand == 2) ||
                    (youHand == 2 &amp;&amp; cpuHand == 0)
            ) {
                System.out.println("結果：勝ち");
            } else {
                System.out.println("結果：負け");
            }

            System.out.println();
        }
    }
}</code></pre>
  </section>

  <section id="explain">
    <h2>プログラム解説</h2>

    <h3>1) interface（Player）＝「契約」</h3>
    <p>
      <strong>Player</strong> は「プレイヤーなら最低限これを提供しろ」という約束です。<br />
      Gameはこの約束だけを見ます。人間かCPUかは知りません（知る必要がありません）。
    </p>
    <ul>
      <li><code>getName()</code>：表示に必要</li>
      <li><code>nextHand()</code>：手を出す（ここがクラスごとに違う）</li>
      <li><code>handLabel(int)</code>：表示に必要</li>
    </ul>

    <h3>2) abstract class（AbstractPlayer）＝「共通の実装」</h3>
    <p>
      <strong>AbstractPlayer</strong> は共通処理をまとめます。
      ただし <code>nextHand()</code> は実装しません。<strong>抽象</strong>にして「子に必ず作らせる」ようにします。
    </p>
    <div class="callout">
      <div><span class="ok">ポイント：</span>abstract は「未完成だから使う」のではなく、「実装を強制するために使う」</div>
      <small>未完成を放置しているわけじゃない。未完成にすることで“約束”が固くなる。</small>
    </div>

    <h3>3) ポリモーフィズム＝「同じ呼び出しで、挙動が変わる」</h3>
    <p>
      <code>you.nextHand()</code> と <code>cpu.nextHand()</code> は<strong>同じメソッド呼び出し</strong>です。<br />
      しかし実行される中身は、
      <strong>HumanPlayer版</strong>（入力）と <strong>CpuPlayer版</strong>（乱数）で変わります。これがポリモーフィズムです。
    </p>
    <div class="callout">
      <div><strong>重要：</strong>Game側に if 分岐はありません。</div>
      <small>もし Game が「人なら入力」「CPUなら乱数」みたいなifを書き始めたら、それは設計が負けてます。</small>
    </div>

    <h3>4) 次のステップ（授業で伸ばすなら）</h3>
    <ul>
      <li><strong>FixedCpuPlayer</strong>（常にグー等）を追加してテストしやすくする</li>
      <li>勝敗カウント（ScoreBoard）を追加して責務分離</li>
      <li>じゃんけんを「ルール（Judge）」クラスに分離（ifの塊を外に出す）</li>
    </ul>

    <p class="meta">
      ここまで来ると「OOPが役に立つ瞬間」が見えます。<br />
      逆に言うと、ここを飛ばして抽象化すると生徒は置いていかれます（抽象は優しさじゃない、暴力にもなる）。
    </p>
  </section>
</main>

<footer>
  <div>© 教材用テンプレート（じゃんけん：OOP版）</div>
  <div>※授業用のため、理解しやすさ優先の構成です。</div>
</footer>
</body>
</html>
