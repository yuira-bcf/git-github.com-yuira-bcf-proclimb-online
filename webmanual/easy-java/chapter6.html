<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ソースファイルを分割する（複数ファイル開発・コンパイル・実行・JAR）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{
      font-family: system-ui, -apple-system, "Segoe UI",
                   "Hiragino Kaku Gothic ProN","Yu Gothic", sans-serif;
      line-height: 1.8;
      margin: 24px;
    }
    h1{ font-size: 1.6rem; margin-bottom: 16px; }
    h2{
      font-size: 1.25rem;
      margin-top: 36px;
      border-left: 6px solid #ccc;
      padding-left: 10px;
    }
    h3{
      font-size: 1.1rem;
      margin-top: 22px;
      border-left: 4px solid #ddd;
      padding-left: 10px;
    }
    p{ margin: 10px 0; }
    ul{ margin-left: 24px; }
    pre{
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 12px;
      overflow-x: auto;
      white-space: pre;
    }
    code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco,
                   Consolas, "Noto Sans Mono", monospace;
    }
    .key{
      background: #eef5ff;
      border-left: 6px solid #7fb3ff;
      border-radius: 8px;
      padding: 14px;
      margin: 16px 0;
      font-weight: bold;
    }
    .box{
      background: #fcfcfc;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      padding: 14px;
      margin: 16px 0;
    }
    .note{
      background: #fff7e6;
      border-left: 6px solid #f0c36d;
      border-radius: 8px;
      padding: 14px;
      margin: 16px 0;
    }
    .summary{
      background: #effaf3;
      border-left: 6px solid #7ad39a;
      border-radius: 8px;
      padding: 14px;
      margin: 20px 0;
      font-weight: bold;
    }
    hr{ border: none; border-top: 1px solid #e6e6e6; margin: 22px 0; }
    table{ border-collapse: collapse; width: 100%; max-width: 920px; margin: 12px 0; }
    th,td{ border: 1px solid #e0e0e0; padding: 10px; text-align: left; vertical-align: top; }
    th{ background:#fafafa; }
  </style>
</head>
<body>

<h1>ソースファイルを分割する</h1>

<section>
  <h2>1. 1つのソースファイルによる開発の限界</h2>
  <p>
    Java では、最初は 1 ファイル（例：<code>Main.java</code>）だけで学習を進められます。
    しかし、規模が少し大きくなると、1 ファイルにすべてを詰め込む方法には限界が出てきます。
  </p>

  <div class="box">
    <p><strong>1ファイル開発で起きやすい問題：</strong></p>
    <ul>
      <li>コードが長くなり、目的の処理を見つけにくくなる</li>
      <li>修正したい場所を間違えやすくなる</li>
      <li>同じような処理が増え、重複が起きやすくなる</li>
      <li>役割が混ざり、全体の理解が難しくなる</li>
      <li>複数人開発では同じファイルを同時編集しづらい</li>
    </ul>
  </div>

  <div class="key">
    規模が大きくなるほど「役割ごとに分割する」ことが必要になります。
  </div>
</section>

<hr>

<section>
  <h2>2. プログラムの分割方法、分割のヒント</h2>

  <h3>2-1. 分割の基本方針</h3>
  <p>
    分割の基本は、<strong>役割ごとにクラスを分ける</strong>ことです。
    たとえば「データを表す」「計算する」「表示する」などの役割を分離します。
  </p>

  <div class="box">
    <p><strong>分割のヒント（よく使う分け方）：</strong></p>
    <ul>
      <li><strong>データを表すクラス</strong>：例）Person、Product など</li>
      <li><strong>処理をまとめるクラス</strong>：例）Calculator、Service など</li>
      <li><strong>実行の入口（main）</strong>：例）Main クラス</li>
      <li><strong>入出力を担当するクラス</strong>：例）ConsoleView、FileIO など</li>
    </ul>
  </div>

  <h3>2-2. 分割例（Main と Person を分ける）</h3>
  <p>
    例として、<code>Person</code> クラスを別ファイルに分割します。
  </p>

  <table>
    <thead>
      <tr>
        <th>ファイル名</th>
        <th>内容</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>Person.java</code></td>
        <td>人の情報（データ）を表すクラス</td>
      </tr>
      <tr>
        <td><code>Main.java</code></td>
        <td>プログラムの開始点（main）を持つクラス</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Person.java</strong></p>
  <pre><code>public class Person {
    String name;
    int age;

    void introduce() {
        System.out.println("私は" + name + "です。年齢は" + age + "歳です。");
    }
}</code></pre>

  <p><strong>Main.java</strong></p>
  <pre><code>public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        p.name = "田中";
        p.age = 20;
        p.introduce();
    }
}</code></pre>

  <div class="note">
    <p>
      <strong>注意：</strong><br>
      同じフォルダ（同じパッケージ）に置けば、
      この例のようにそのまま利用できます。<br>
      パッケージを使う場合は、ファイル先頭に <code>package</code> 文が必要になります。
    </p>
  </div>
</section>

<hr>

<section>
  <h2>3. 複数クラスのコンパイル</h2>
  <p>
    複数ファイルに分割した場合でも、コンパイルの考え方は同じです。
    Java は <code>.java</code> をコンパイルして <code>.class</code>（実行用）を作成します。
  </p>

  <h3>3-1. すべての .java をまとめてコンパイル</h3>
  <pre><code>javac Main.java Person.java</code></pre>

  <p>
    ファイルが多い場合は、次のようにまとめて指定できます。
  </p>
  <pre><code>javac *.java</code></pre>

  <div class="note">
    <p>
      <strong>補足：</strong><br>
      Java は依存関係を見て必要なクラスをコンパイルしますが、<br>
      学習段階では <code>javac *.java</code> のようにまとめてコンパイルすると分かりやすいです。
    </p>
  </div>
</section>

<hr>

<section>
  <h2>4. プログラムの実行方法</h2>

  <h3>4-1. 基本の実行方法</h3>
  <p>
    コンパイルで <code>.class</code> が生成されたら、
    <code>java</code> コマンドで実行します。
  </p>

  <pre><code>java Main</code></pre>

  <div class="note">
    <p>
      <strong>注意：</strong><br>
      実行時には拡張子を付けません。<br>
      <code>java Main.class</code> ではなく <code>java Main</code> です。
    </p>
  </div>

  <h3>4-2. よくあるつまずき</h3>
  <div class="box">
    <ul>
      <li><strong>クラス名とファイル名の不一致</strong>：<code>public class Person</code> は <code>Person.java</code> にする</li>
      <li><strong>コンパイルしていない</strong>：<code>.class</code> が存在しないと実行できない</li>
      <li><strong>パッケージを使っている</strong>：実行コマンドが変わる（例：<code>java jp.example.Main</code>）</li>
    </ul>
  </div>
</section>

<hr>

<section>
  <h2>5. JARファイルとは</h2>
  <p>
    <strong>JARファイル</strong>（Jar Archive）とは、
    Java のクラスファイルや設定ファイルなどを
    <strong>1つにまとめたファイル</strong>です。
  </p>

  <div class="key">
    JAR = Java のプログラム一式を「配布しやすい形」にまとめたもの
  </div>

  <h3>5-1. なぜ JAR にするのか</h3>
  <ul>
    <li>複数の <code>.class</code> をまとめて配布できる</li>
    <li>実行に必要なファイルを一括で管理できる</li>
    <li>ライブラリ（再利用部品）として配布できる</li>
  </ul>

  <h3>5-2. JAR の実行（代表例）</h3>
  <p>
    実行用 JAR を作ると、次のように実行できます。
  </p>
  <pre><code>java -jar app.jar</code></pre>

  <div class="note">
    <p>
      <strong>補足：</strong><br>
      <code>java -jar</code> で実行するためには、JAR 内に
      「どのクラスの main を起動するか」という情報（Manifest）が必要です。<br>
      学習段階では、まず「JAR はまとめて配布する形式」と理解しておけば十分です。
    </p>
  </div>
</section>

<hr>

<section>
  <h2>まとめ</h2>
  <div class="summary">
    ・1ファイル開発は小規模なら可能だが、規模が大きくなると読みづらくなり限界が出る。<br>
    ・分割は「役割ごとにクラスを分ける」のが基本である（データ・処理・実行入口など）。<br>
    ・複数ファイルは <code>javac Main.java Person.java</code> や <code>javac *.java</code> でコンパイルできる。<br>
    ・実行は <code>java Main</code> のようにクラス名で行う（拡張子は付けない）。<br>
    ・JAR はクラスなどをまとめて配布・実行しやすくした形式で、<code>java -jar</code> で実行できる。
  </div>
</section>

<section>
  <h2>0. 前提（このページで扱うルール）</h2>
  <div class="key">
    ① public クラス名とファイル名は一致させます。<br>
    ② ここでは「同じフォルダ（同じパッケージ）」に置く前提で進めます。<br>
    ③ コンパイルは <code>javac</code>、実行は <code>java</code> を使います。
  </div>
</section>

<hr>

<h1>ソースファイルを分割する（基礎練習問題：解答例・解説付き）</h1>

<section>
  <h2>0. 前提（このページで扱うルール）</h2>
  <div class="key">
    ① public クラス名とファイル名は一致させます。<br>
    ② ここでは「同じフォルダ（同じパッケージ）」に置く前提で進めます。<br>
    ③ コンパイルは <code>javac</code>、実行は <code>java</code> を使います。
  </div>
</section>

<hr>

<section>
  <h2>問題1：クラスを分割してみよう（基本）</h2>

  <h3>問題</h3>
  <ul>
    <li><code>Main</code> クラスと <code>Student</code> クラスを作成する</li>
    <li><code>Student</code> クラスは「名前」と「点数」を持つ</li>
    <li><code>Student</code> クラスに情報を表示するメソッドを作成する</li>
    <li><code>Main</code> クラスの <code>main</code> メソッドから呼び出す</li>
  </ul>

  <h3>解答例</h3>

  <table>
    <thead>
      <tr>
        <th>ファイル名</th>
        <th>役割</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>Student.java</code></td>
        <td>学生データ（名前・点数）と、表示処理を持つ</td>
      </tr>
      <tr>
        <td><code>Main.java</code></td>
        <td>実行の入口（main）で Student を作って動かす</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Student.java</strong></p>
  <pre><code>public class Student {
    String name;
    int score;

    void show() {
        System.out.println("名前: " + name);
        System.out.println("点数: " + score);
    }
}</code></pre>

  <p><strong>Main.java</strong></p>
  <pre><code>public class Main {
    public static void main(String[] args) {

        Student s = new Student();
        s.name = "田中";
        s.score = 80;

        s.show();
    }
}</code></pre>

  <h3>解説</h3>
  <div class="answer">
    <p><strong>分割の考え方：</strong></p>
    <ul>
      <li><code>Student</code> は「データを表す役割」なので <code>Student.java</code> に分けます。</li>
      <li><code>Main</code> は「実行の入口」なので、動作確認のための処理をここにまとめます。</li>
      <li>この分割により、Student の仕様変更（項目追加など）を Student 側で完結しやすくなります。</li>
    </ul>
  </div>
</section>

<hr>

<section>
  <h2>問題2：複数ファイルをコンパイルして実行しよう</h2>

  <h3>問題</h3>
  <ol>
    <li>両方の <code>.java</code> をコンパイルする</li>
    <li>生成された <code>.class</code> を確認する</li>
    <li><code>Main</code> を実行する</li>
  </ol>

  <h3>解答例</h3>
  <pre><code>javac Main.java Student.java
java Main</code></pre>

  <p>ファイルが増えた場合の例：</p>
  <pre><code>javac *.java
java Main</code></pre>

  <h3>解説</h3>
  <div class="answer">
    <ul>
      <li><code>javac</code> は「.java → .class」に変換します（コンパイル）。</li>
      <li><code>java</code> は「.class を実行」します（起動）。</li>
      <li>実行時は拡張子を付けません。<code>java Main</code> が正しい書き方です。</li>
    </ul>
  </div>

  <div class="note">
    <p><strong>よくあるミス：</strong></p>
    <ul>
      <li><code>java Main.java</code> としてしまう（これは誤りです）</li>
      <li>コンパイルしていないため <code>Main.class</code> がない</li>
      <li>ファイル名と public クラス名が一致していない</li>
    </ul>
  </div>
</section>

<hr>

<section>
  <h2>問題3：処理用クラスを追加しよう（発展）</h2>

  <h3>問題</h3>
  <ul>
    <li><code>Calculator</code> クラスを新しく作成する</li>
    <li>点数の合計を計算するメソッドを作成する</li>
    <li><code>Main</code> クラスから <code>Calculator</code> を利用する</li>
    <li><code>Main</code> に計算処理を書かない</li>
  </ul>

  <h3>解答例</h3>

  <p><strong>Calculator.java</strong></p>
  <pre><code>public class Calculator {

    // Student の配列を受け取り、点数の合計を返す
    int sumScores(Student[] students) {
        int sum = 0;
        for (int i = 0; i &lt; students.length; i++) {
            sum += students[i].score;
        }
        return sum;
    }
}</code></pre>

  <p><strong>Main.java（差し替え例）</strong></p>
  <pre><code>public class Main {
    public static void main(String[] args) {

        Student s1 = new Student();
        s1.name = "田中";
        s1.score = 80;

        Student s2 = new Student();
        s2.name = "佐藤";
        s2.score = 90;

        Student[] list = {s1, s2};

        Calculator calc = new Calculator();
        int total = calc.sumScores(list);

        System.out.println("合計点: " + total);
    }
}</code></pre>

  <h3>解説</h3>
  <div class="answer">
    <p><strong>分割の狙い：</strong></p>
    <ul>
      <li><code>Main</code> は「実行の流れ」を担当します。</li>
      <li><code>Calculator</code> は「計算処理」を担当します。</li>
      <li>計算のルールが変わっても、<code>Calculator</code> だけを修正すれば済むようになります。</li>
    </ul>
  </div>
</section>

<hr>

<section>
  <h2>問題4：理解度チェック（○×）</h2>

  <h3>問題</h3>
  <ol>
    <li>public クラスの名前とファイル名は一致していなければならない</li>
    <li>複数のクラスは、1つの <code>.java</code> ファイルに書かなければならない</li>
    <li><code>javac</code> はソースファイルをコンパイルするコマンドである</li>
    <li><code>java</code> コマンドでは <code>.class</code> 拡張子を付けて実行する</li>
    <li>JAR ファイルは、複数のクラスをまとめたものである</li>
  </ol>

  <h3>解答</h3>
  <div class="answer">
    <ol>
      <li>○</li>
      <li>×</li>
      <li>○</li>
      <li>×</li>
      <li>○</li>
    </ol>
  </div>

  <h3>解説</h3>
  <div class="answer">
    <ul>
      <li>1：○（<code>public class Person</code> は <code>Person.java</code> にする必要があります）</li>
      <li>2：×（分割して複数ファイルにするのが一般的です）</li>
      <li>3：○（<code>.java</code> を <code>.class</code> に変換します）</li>
      <li>4：×（<code>java Main</code> のように拡張子を付けません）</li>
      <li>5：○（配布しやすい形にまとめたアーカイブです）</li>
    </ul>
  </div>
</section>

<hr>

<section>
  <h2>問題5：まとめ課題（自由記述）</h2>

  <h3>問題</h3>
  <ul>
    <li>なぜ、ソースファイルを分割する必要があるのか</li>
    <li>1つのクラスに多くの役割を持たせると、どのような問題が起きるか</li>
    <li>今後、どのような基準でクラスを分けたいか</li>
  </ul>

  <h3>解答例（模範例）</h3>
  <div class="answer">
    <ul>
      <li>
        <strong>分割が必要な理由：</strong>
        コードが長くなると目的の処理を探しにくくなり、修正ミスも増えるためです。
        役割ごとに分割すると、見通しが良くなり、保守がしやすくなります。
      </li>
      <li>
        <strong>役割が混ざる問題：</strong>
        例えば Main に「入力」「計算」「表示」「データ」すべてを書いてしまうと、
        どこを直せばよいか分かりにくくなり、修正が他の部分に影響しやすくなります。
      </li>
      <li>
        <strong>分割の基準：</strong>
        「データ」「処理」「表示」「実行の流れ」を分けるようにします。
        特に、計算ルールやデータ構造が変わりそうな部分は別クラスにします。
      </li>
    </ul>
  </div>

  <div class="note">
    <p>
      自由記述は、正解よりも「説明できること」が重要です。<br>
      自分の言葉で書ければ理解が深まっています。
    </p>
  </div>
</section>

<hr>

<section>
  <h2>まとめ</h2>
  <div class="summary">
    ・ソースファイルを分割すると、役割が整理され、読みやすく修正しやすくなります。<br>
    ・複数ファイルでもコンパイルと実行の基本は同じで、<code>javac</code> と <code>java</code> を使います。<br>
    ・データ（Student）と処理（Calculator）と実行入口（Main）を分けると、変更に強い構造になります。<br>
    ・JAR はクラスファイル等をまとめて配布・実行しやすくした形式です。
  </div>
</section>
<h1>パッケージを利用する</h1>

<section>
  <h2>1. パッケージの概要</h2>
  <p>
    <strong>パッケージ（package）</strong>とは、クラスを整理するための仕組みです。
    フォルダ構造のようにクラスを分類し、名前の衝突を防ぎます。
  </p>

  <div class="key">
    パッケージ = クラスを整理する「名前空間」<br>
    （同じクラス名でもパッケージが違えば別物として扱える）
  </div>

  <div class="box">
    <p><strong>パッケージを使う目的：</strong></p>
    <ul>
      <li>クラスを役割ごとに整理して見通しを良くする</li>
      <li>同名クラスの衝突を防ぐ（例：User が複数あっても区別できる）</li>
      <li>アクセス制御や設計（層の分離）をしやすくする</li>
    </ul>
  </div>
</section>

<hr>

<section>
  <h2>2. パッケージの定義</h2>

  <h3>2-1. 定義</h3>
  <p>
    パッケージは、ソースファイルの先頭に <code>package</code> 文を書いて定義します。
    <strong>必ず1行目付近（通常は先頭行）</strong>に記述します。
  </p>

  <pre><code>package jp.example.app;</code></pre>

  <div class="note">
    <p><strong>注意：</strong></p>
    <ul>
      <li><code>package</code> 文より前に書けるのは、基本的にコメントのみです。</li>
      <li>パッケージ名は通常、小文字で書きます（慣習）。</li>
    </ul>
  </div>

  <h3>2-2. サンプルコード</h3>
  <p><strong>ファイル構成（例）</strong></p>
  <pre><code>src/
  jp/
    example/
      app/
        Main.java
        model/
          Person.java</code></pre>

  <p><strong>Person.java</strong></p>
  <pre><code>package jp.example.app.model;

public class Person {
    public String name;

    public void hello() {
        System.out.println("こんにちは、" + name + "です。");
    }
}</code></pre>

  <p><strong>Main.java</strong></p>
  <pre><code>package jp.example.app;

import jp.example.app.model.Person;

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        p.name = "田中";
        p.hello();
    }
}</code></pre>
</section>

<hr>

<section>
  <h2>3. デフォルトパッケージとは</h2>

  <p>
    <strong>デフォルトパッケージ</strong>とは、
    <code>package</code> 文を書かずに作成したクラスが属する「無名のパッケージ」のことです。
  </p>

  <div class="note">
    <p><strong>ポイント：</strong></p>
    <ul>
      <li>学習の最初はデフォルトパッケージでも動きます。</li>
      <li>しかし、実務では通常デフォルトパッケージは使いません。</li>
    </ul>
  </div>

  <div class="box">
    <p><strong>デフォルトパッケージを避ける理由（代表例）：</strong></p>
    <ul>
      <li>パッケージ付きのクラスから import できない、など扱いが不便になる</li>
      <li>フォルダ構造で整理できず、規模が大きくなると管理しづらい</li>
      <li>同名クラスの衝突が起きやすい</li>
    </ul>
  </div>

  <div class="key">
    学習初期はOKですが、基本的には「パッケージを付ける」が正しい習慣です。
  </div>
</section>

<hr>

<section>
  <h1 style="font-size:1.35rem; margin-top:40px;">パッケージ名を含むクラス名を指定</h1>
  <h2 style="margin-top:18px;">4. 概要</h2>

  <p>
    パッケージを使うと、クラス名だけではどのクラスか分からない場合があります。
    そのときは、<strong>パッケージ名を含むクラス名</strong>で指定できます。
  </p>

  <div class="key">
    パッケージ名を含むクラス名（完全修飾クラス名）でクラスを指定できる
  </div>

  <h2>5. 定義（完全修飾クラス名）</h2>
  <p>
    パッケージ名を含むクラス名を、<strong>完全修飾クラス名</strong>と呼びます。
  </p>

  <pre><code>jp.example.app.model.Person</code></pre>

  <h2>6. サンプルコード（完全修飾クラス名を直接書く）</h2>
  <p>
    <code>import</code> を使わずに、完全修飾クラス名で直接利用する例です。
  </p>

  <pre><code>package jp.example.app;

public class Main {
    public static void main(String[] args) {

        jp.example.app.model.Person p = new jp.example.app.model.Person();
        p.name = "佐藤";
        p.hello();
    }
}</code></pre>

  <div class="note">
    <p>
      この書き方は確実に動きますが、長くなって読みにくくなります。<br>
      そこで次の「import」を使います。
    </p>
  </div>
</section>

<hr>

<section>
  <h1 style="font-size:1.35rem; margin-top:40px;">完全修飾クラス名の入力を省略</h1>
  <h2 style="margin-top:18px;">7. 概要</h2>

  <p>
    完全修飾クラス名（パッケージ名 + クラス名）を毎回書くと長くなるため、
    Java では <strong>import</strong> を使って省略できます。
  </p>

  <div class="key">
    import を使うと、クラス名だけで書けるようになる
  </div>

  <h2>8. 定義（import）</h2>
  <p>
    <code>import</code> は、<strong>使用したいクラスを先に宣言する</strong>ための文です。
    <code>package</code> 文の後に書きます。
  </p>

  <pre><code>package jp.example.app;

import jp.example.app.model.Person;</code></pre>

  <div class="note">
    <p><strong>補足：</strong></p>
    <ul>
      <li><code>java.lang</code> パッケージ（例：String）は自動的に import されるため、通常 import は不要です。</li>
      <li><code>import jp.example.app.model.*;</code> のようにまとめて import することもできますが、学習段階では個別 import が分かりやすいです。</li>
    </ul>
  </div>

  <h2>9. サンプルコード（import で省略）</h2>
  <pre><code>package jp.example.app;

import jp.example.app.model.Person;

public class Main {
    public static void main(String[] args) {

        Person p = new Person();
        p.name = "鈴木";
        p.hello();
    }
}</code></pre>

  <div class="box">
    <p><strong>完全修飾クラス名と import の違い：</strong></p>
    <ul>
      <li>完全修飾クラス名：その場でフルネームを書く（確実だが長い）</li>
      <li>import：先に宣言して、クラス名だけで書ける（読みやすい）</li>
    </ul>
  </div>
</section>

<hr>

<section>
  <h2>まとめ</h2>
  <div class="summary">
    ・パッケージはクラスを整理し、名前の衝突を防ぐ仕組みである。<br>
    ・パッケージはソース先頭の <code>package</code> 文で定義する。<br>
    ・デフォルトパッケージは <code>package</code> 文なしの状態であり、学習初期以外では避けるのが一般的である。<br>
    ・完全修飾クラス名（パッケージ名＋クラス名）でクラスを指定できる。<br>
    ・<code>import</code> を使うと完全修飾クラス名を省略でき、コードが読みやすくなる。
  </div>
</section>

<h1>パッケージに属したクラスの実行方法</h1>

<section>
  <h2>1. 正しいクラス名の指定</h2>
  <p>
    パッケージに属したクラスを実行する場合、
    <strong>クラス名だけ</strong>ではなく、
    <strong>パッケージ名を含めたクラス名</strong>を指定します。
  </p>

  <div class="key">
    実行時は「完全修飾クラス名」を指定する
  </div>

  <h3>例：パッケージ付きクラス</h3>
  <pre><code>package jp.example.app;

public class Main {
    public static void main(String[] args) {
        System.out.println("Hello");
    }
}</code></pre>

  <p>
    このクラスを実行する場合、コマンドは次のようになります。
  </p>

  <pre><code>java jp.example.app.Main</code></pre>

  <div class="note">
    <p>
      <strong>注意：</strong><br>
      実行時に指定するのは <code>Main.class</code> ではありません。<br>
      あくまで「パッケージ名 + クラス名」です。
    </p>
  </div>
</section>

<hr>

<section>
  <h2>2. クラス名だけでクラスファイルを探し出すための仕組み</h2>

  <p>
    <code>java jp.example.app.Main</code> と実行したとき、
    Java はどのようにして <code>Main.class</code> を探しているのでしょうか。
  </p>

  <div class="key">
    クラスの読み込みは JVM とクラスローダーが担当する
  </div>

  <h3>2-1. JVM（Java Virtual Machine）</h3>
  <p>
    <strong>JVM</strong> は、Java プログラムを実行する仮想マシンです。
    Java のプログラムは、直接 OS 上で動くのではなく、
    JVM の中で動作します。
  </p>

  <div class="box">
    <p><strong>JVM の役割（概要）：</strong></p>
    <ul>
      <li>Java プログラムの実行</li>
      <li>メモリ管理</li>
      <li>クラスの読み込み管理</li>
    </ul>
  </div>

  <h3>2-2. クラスローダー</h3>
  <p>
    <strong>クラスローダー</strong>は、
    JVM の中でクラスファイルを探して読み込む仕組みです。
  </p>

  <p>
    JVM は、指定された完全修飾クラス名をもとに、
    次のように考えます。
  </p>

  <div class="box">
    <ol>
      <li>クラスパスに指定された場所を調べる</li>
      <li>パッケージ名をフォルダ構造として解釈する</li>
      <li>対応する <code>.class</code> ファイルを探す</li>
    </ol>
  </div>

  <p>
    たとえば、
  </p>

  <pre><code>jp.example.app.Main</code></pre>

  <p>
    は、次の場所を意味します。
  </p>

  <pre><code>jp/example/app/Main.class</code></pre>
</section>

<hr>

<section>
  <h2>3. クラスパスの指定方法</h2>

  <p>
    <strong>クラスパス（classpath）</strong>とは、
    JVM がクラスファイルを探しに行く
    <strong>基準となる場所</strong>です。
  </p>

  <div class="key">
    クラスパス = クラスを探す「出発点」
  </div>

  <h3>3-1. コマンドで指定する方法</h3>
  <p>
    実行時に <code>-cp</code>（または <code>-classpath</code>）を使って指定します。
  </p>

  <pre><code>java -cp . jp.example.app.Main</code></pre>

  <p>
    この例では、<code>.</code>（カレントディレクトリ）が
    クラスパスとして指定されています。
  </p>

  <h3>3-2. 環境変数で指定する方法</h3>
  <p>
    環境変数 <code>CLASSPATH</code> に設定する方法もありますが、
    学習段階ではあまり推奨されません。
  </p>

  <div class="note">
    <p>
      理由：設定内容が見えにくく、トラブルの原因になりやすいためです。
    </p>
  </div>
</section>

<hr>

<section>
  <h2>4. クラスパスで指定できる対象</h2>

  <p>
    クラスパスには、次のようなものを指定できます。
  </p>

  <table>
    <thead>
      <tr>
        <th>指定できるもの</th>
        <th>説明</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>ディレクトリ</td>
        <td>その配下からクラスファイルを探す</td>
      </tr>
      <tr>
        <td>JAR ファイル</td>
        <td>JAR 内のクラスを読み込む</td>
      </tr>
      <tr>
        <td>複数指定</td>
        <td>複数の場所をまとめて指定できる</td>
      </tr>
    </tbody>
  </table>

  <p>複数指定の例：</p>
  <pre><code>java -cp .;lib/app.jar jp.example.app.Main</code></pre>

  <div class="note">
    <p>
      Windows では <code>;</code>、macOS / Linux では <code>:</code> を区切り文字として使います。
    </p>
  </div>
</section>

<hr>

<section>
  <h2>5. クラスファイルの正しい配置</h2>

  <p>
    パッケージを使う場合、クラスファイルは
    <strong>パッケージ構造と一致したフォルダ</strong>に配置する必要があります。
  </p>

  <h3>正しい配置例</h3>
  <pre><code>bin/
  jp/
    example/
      app/
        Main.class</code></pre>

  <p>
    この場合、クラスパスには <code>bin</code> を指定します。
  </p>

  <pre><code>java -cp bin jp.example.app.Main</code></pre>

  <div class="note">
    <p>
      フォルダ構造とパッケージ名が一致していない場合、
      JVM はクラスを見つけられずエラーになります。
    </p>
  </div>
</section>

<hr>

<section>
  <h2>まとめ</h2>
  <div class="summary">
    ・パッケージに属したクラスを実行する場合は、完全修飾クラス名を指定する。<br>
    ・JVM はクラスローダーを使い、クラスパスを基準にクラスを探す。<br>
    ・クラスパスは「クラス探索の出発点」であり、-cp オプションで指定できる。<br>
    ・クラスパスにはディレクトリや JAR ファイルを指定できる。<br>
    ・クラスファイルは、パッケージ構造と一致する場所に正しく配置する必要がある。
  </div>
</section>

</body>
</html>
