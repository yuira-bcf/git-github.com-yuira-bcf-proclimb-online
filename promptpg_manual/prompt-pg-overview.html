<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>プロンプトプログラミング概論</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #fafafa;
      --surface: #ffffff;
      --text: #222222;
      --muted: #5f6368;
      --accent: #1b5e20;
      --border: #e0e0e0;
      --code-bg: #f3f4f6;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo", sans-serif;
      line-height: 1.7;
      color: var(--text);
      background: var(--bg);
    }

    .layout {
      width: 100%;
      margin: 0;
      padding: 16px 2vw;
      display: grid;
      grid-template-columns: 350px 1fr;
      gap: 16px;
    }

    .toc {
      position: sticky;
      top: 16px;
      align-self: start;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px 14px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.06);
    }

    .toc h2 {
      margin: 0 0 8px;
      font-size: 16px;
      color: var(--muted);
    }

    .toc ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .toc li {
      margin: 6px 0;
    }

    .toc a {
      color: var(--text);
      text-decoration: none;
      display: block;
      padding: 6px 8px;
      border-radius: 6px;
    }

    .toc a:hover,
    .toc a:focus {
      background: var(--code-bg);
    }

    main {
      max-width: none;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }

    section {
      margin: 0 0 16px;
      padding: 24px 20px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.06);
    }

    h1 {
      margin: 0 0 16px;
      font-size: 28px;
      border-left: 6px solid var(--accent);
      padding-left: 12px;
    }

    h2 {
      margin: 24px 0 12px;
      font-size: 22px;
    }

    h3 {
      margin: 20px 0 8px;
      font-size: 18px;
      color: var(--accent);
    }

    p {
      margin: 10px 0;
    }

    ul,
    ol {
      margin: 8px 0 12px 20px;
      padding: 0;
    }

    li {
      margin: 6px 0;
    }

    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: var(--code-bg);
      padding: 0 4px;
      border-radius: 4px;
    }

    pre {
      background: var(--code-bg);
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
      border: 1px solid var(--border);
    }

    pre code {
      background: transparent;
      padding: 0;
    }

    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 24px 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 12px 0 16px;
    }

    th,
    td {
      border: 1px solid var(--border);
      padding: 8px 10px;
      text-align: left;
      vertical-align: top;
    }

    thead th {
      background: var(--code-bg);
    }

    em {
      color: var(--muted);
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .toc {
        position: static;
      }
    }
  </style>
</head>
<body>
  <div class="layout">
    <nav class="toc">
      <h2>目次</h2>
      <ul>
        <li><a href="#chapter-1">プロンプトプログラミングの重要性と必要性</a></li>
        <li><a href="#chapter-2">プロンプトプログラミングを進める手順（再確認・ブラッシュアップ版）</a></li>
        <li><a href="#chapter-3">プロンプトプログラミング：工程別テンプレート集（コピペ用）</a></li>
      </ul>
    </nav>
    <main>
    <section>
<h1 id="chapter-1">プロンプトプログラミングの重要性と必要性</h1>
<h2>1. はじめに</h2>
<p>近年の大規模言語モデル（LLM）の発展により、 自然言語によってプログラム成果物を生成することが一般的になりつつあります。 このような状況の中で注目されているのが、 <strong>プロンプトを中心に開発を進める「プロンプトプログラミング」</strong>という考え方です。</p>
<p>本稿では、プロンプトプログラミングがなぜ重要であり、 今後なぜ必要不可欠な技術・思考法となるのかについて整理します。</p>
<hr>
<h2>2. プログラミングを取り巻く前提の変化</h2>
<p>従来、プログラミングとは 「人間がコードを直接記述する行為」を中心に定義されてきました。 アルゴリズムを考え、文法に従って実装し、 試行錯誤しながら完成させることが、開発の中心的な作業でした。</p>
<p>しかし現在では、AIが一定水準以上のコードを短時間で生成できる環境が整っています。 この変化により、開発の重心は次第に <strong>コードを書く作業そのものから、何をどのように作らせるかを定義する作業</strong>へと移行しています。</p>
<p>この移行を支える中心的な役割を担うのが、プロンプトプログラミングです。</p>
<hr>
<h2>3. プロンプトプログラミングの重要性</h2>
<h3>3.1 開発効率の大幅な向上</h3>
<p>プロンプトプログラミングを用いることで、 定型的な処理や繰り返し実装が必要な部分をAIに任せることができます。 その結果、人間は以下のような作業に集中できます。</p>
<ul>
<li>要件の整理</li>
<li>設計の妥当性検討</li>
<li>出力結果の評価と修正指示</li>
</ul>
<p>これは単なる作業時間の短縮にとどまらず、 <strong>開発の質そのものを高めることにつながります</strong>。</p>
<hr>
<h3>3.2 プログラム品質の安定化</h3>
<p>プロンプトを設計資産として整理し、 制約条件や出力形式を明確にしたうえでAIに指示を出すことで、 成果物の品質は一定水準に保たれやすくなります。</p>
<p>場当たり的にコードを書く場合と比較して、 <strong>再現性のある開発プロセスを構築できる点</strong>は大きな利点です。</p>
<hr>
<h3>3.3 人間の役割の明確化</h3>
<p>プロンプトプログラミングでは、 人間は「実装者」ではなく「設計者・判断者」としての役割を強く担います。</p>
<ul>
<li>何を作るのかを決める</li>
<li>どこまでを許容し、どこを制限するのかを定める</li>
<li>出力結果が要件を満たしているかを評価する</li>
</ul>
<p>これらの役割はAIに代替できない部分であり、 <strong>人間の判断力や責任がより明確に求められるようになります</strong>。</p>
<hr>
<h2>4. プロンプトプログラミングの必要性</h2>
<h3>4.1 実務開発における必然性</h3>
<p>実務の開発現場では、新規実装よりも次のような作業が多くを占めます。</p>
<ul>
<li>仕様変更への対応</li>
<li>既存コードの修正</li>
<li>バグの再現条件整理と修正指示</li>
</ul>
<p>これらの作業では、 正確な状況説明と制約条件の言語化が不可欠です。</p>
<p>プロンプトプログラミングは、 このような実務における<strong>説明力・指示力を体系化する手法</strong>として、今後ますます重要になります。</p>
<hr>
<h3>4.2 教育分野における必要性</h3>
<p>プログラミング教育においても、 単に文法や構文を覚えるだけでは不十分になりつつあります。</p>
<p>プロンプトプログラミングを通じて、</p>
<ul>
<li>要件を文章で整理する力</li>
<li>出力結果を読み取り、正否を判断する力</li>
<li>改善点を具体的に指示する力</li>
</ul>
<p>を養うことは、 将来の実務に直結する能力の育成につながります。</p>
<hr>
<h3>4.3 初学者から上級者まで共通の基盤</h3>
<p>プロンプトプログラミングは、 特定のレベルの技術者だけに必要なものではありません。</p>
<ul>
<li>初学者にとっては、設計思考を学ぶ入口となり</li>
<li>中級者にとっては、開発効率と品質を高める手段となり</li>
<li>上級者にとっては、複雑な要件を整理・伝達する基盤となります</li>
</ul>
<p>このように、<strong>幅広い層に共通して必要とされる基礎能力</strong>である点も重要です。</p>
<hr>
<h2>5. 結論</h2>
<p>プロンプトプログラミングは、 単なるAI活用テクニックではなく、 <strong>現代のソフトウェア開発における前提条件の変化に対応するための必然的な手法</strong>です。</p>
<p>今後重要となるのは、</p>
<ul>
<li>コードを直接書く量ではなく</li>
<li>仕様を正確に言語化し</li>
<li>成果物を評価・修正できる能力</li>
</ul>
<p>です。</p>
<p>プロンプトプログラミングを体系的に理解し、 設計資産として運用することは、 今後のプログラミングにおいて欠かすことのできない要件であるといえます。</p>
    </section>
    <section>
<h1 id="chapter-2">プロンプトプログラミングを進める手順（再確認・ブラッシュアップ版）</h1>
<h2>0. この手順が狙うこと</h2>
<p>この手順は、プロンプトプログラミングを「会話で進める」から一段引き上げて、 <strong>再現性・品質・変更耐性がある“開発プロセス”として運用する</strong>ことを目的に整理しています。</p>
<p>前回の流れに大きな誤りはありませんでしたが、次の点を補強してブラッシュアップしました。</p>
<ul>
<li>各フェーズで <strong>入力 / 出力（成果物）/ 合格条件</strong> を明確化</li>
<li>仕様の抜け・曖昧さを <strong>仮定として固定</strong>する工程を追加</li>
<li>「実装 → テスト → 修正」の反復を <strong>変更管理（差分・理由・影響）</strong>として明文化</li>
<li>プロンプトを <strong>資産として保存する単位</strong>を整理</li>
</ul>
<hr>
<h2>1. 前提（役割分担）を明確にします</h2>
<p>プロンプトプログラミングは「AIが全部やる」ではなく、役割が分かれます。</p>
<ul>
<li><strong>人間がすること</strong></li>
<ul>
<li>目的・仕様・制約・合格条件を決めます</li>
<li>出力物を読み、妥当性を判断します</li>
<li>実行して動作確認します（※コードを直接編集しない運用でも、実行検証は必須です）</li>
<li>変更要求（差分）を出します</li>
</ul>
</ul>
<ul>
<li><strong>AIがすること</strong></li>
<ul>
<li>設計案を出します</li>
<li>実装（コード）を生成します</li>
<li>テスト観点・テスト手順を作ります</li>
<li>修正案（差分）を出します</li>
</ul>
</ul>
<p>ここが曖昧だと「誰が責任を持つか」が崩れます。最初に固定します。</p>
<hr>
<h2>2. 全体フロー（結論）</h2>
<p>プロンプトプログラミングの標準フローは次の順で回します。</p>
<ol>
<li><strong>基本ルール固定（Baseline）</strong></li>
<li><strong>目的・範囲の確定（Scope）</strong></li>
<li><strong>要件定義（Requirements）</strong></li>
<li><strong>仮定と未決定事項の固定（Assumptions）</strong></li>
<li><strong>設計（Design）</strong></li>
<li><strong>実装生成（Implementation）</strong></li>
<li><strong>検証（Verification）</strong></li>
<li><strong>レビューと改善（Review）</strong></li>
<li><strong>変更管理しながら反復（Change Control）</strong></li>
<li><strong>資産化（Assetization）</strong></li>
</ol>
<p>重要なのは、 <strong>「いきなり実装」ではなく、要件→設計→実装→検証の順を守る</strong>ことです。 順番を飛ばすと、出力がブレて修正コストが爆増します（AIが悪いのではなく、人間の指示が曖昧なままになるからです）。</p>
<hr>
<h2>3. 各フェーズの手順（入力・出力・合格条件つき）</h2>
<h3>Phase 1：基本ルール固定（Baseline）</h3>
<p><strong>目的</strong>：以降ずっと適用する“変えない前提”を固定します。 <strong>入力</strong>：技術制約、禁止事項、出力形式、品質基準 <strong>出力（成果物）</strong>：基本ルールプロンプト（1枚） <strong>合格条件</strong>：矛盾がない／禁止事項が明確／出力形式が固定</p>
<p><strong>最低限入れる項目</strong></p>
<ul>
<li>禁止：DB、Web、外部API、ネットワーク通信（必要に応じて）</li>
<li>使用言語と範囲：例）Java Bronze範囲</li>
<li>出力形式：ファイル単位、コード全文、命名規約</li>
<li>品質：入力バリデーション、例外で落とさない、ログ方針</li>
</ul>
<hr>
<h3>Phase 2：目的・範囲の確定（Scope）</h3>
<p><strong>目的</strong>：何を作り、何を作らないかを決めます。 <strong>入力</strong>：目的、想定ユーザー、実行形態（コンソール / GUI） <strong>出力</strong>：スコープ定義（in/out） <strong>合格条件</strong>：「完成」が何か説明できる／やらないことが書かれている</p>
<p><strong>ここで決める例</strong></p>
<ul>
<li>in：基本機能、必須の画面・操作</li>
<li>out：ネット対戦、ランキングサーバ、課金、画像演出など</li>
</ul>
<hr>
<h3>Phase 3：要件定義（Requirements）</h3>
<p><strong>目的</strong>：AIが迷わないレベルまで振る舞いを文章化します。 <strong>入力</strong>：機能要件、非機能要件、入力形式、出力形式 <strong>出力</strong>：要件一覧、受入条件（Acceptance Criteria） <strong>合格条件</strong>：テスト観点に落とせる／曖昧語（適切に、いい感じに）が減っている</p>
<p><strong>必ず入れると事故が減る項目</strong></p>
<ul>
<li>入力の許容範囲（例：g/c/p のみ、大小文字は許可）</li>
<li>不正入力時の動き（再入力、エラーメッセージ）</li>
<li>データ保持（メモリのみ or ファイル保存）</li>
<li>メニュー操作や終了条件</li>
</ul>
<hr>
<h3>Phase 4：仮定と未決定事項の固定（Assumptions）</h3>
<p><strong>目的</strong>：仕様の空白をAIが勝手に埋めてブレるのを防ぎます。 <strong>入力</strong>：決まっていない点、選択肢 <strong>出力</strong>：仮定リスト（Assumptions）＋未決定リスト（Open Issues） <strong>合格条件</strong>：AIが推測で決める余地が減っている</p>
<p><strong>例</strong></p>
<ul>
<li>仮定：勝率は「あいこ含む」「あいこ除外」の両方を表示する</li>
<li>未決定：ファイル保存形式はCSVにするかJSONにするか</li>
</ul>
<hr>
<h3>Phase 5：設計（Design）</h3>
<p><strong>目的</strong>：コードの前に構造を固めます。 <strong>入力</strong>：要件＋仮定 <strong>出力</strong>：クラス構成、責務、主要メソッド、データ構造、処理フロー <strong>合格条件</strong>：人間が読んで理解できる／要件が設計に対応している（抜けがない）</p>
<p><strong>よくあるミス</strong></p>
<ul>
<li>Mainに全部詰め込み（修正が地獄になります）</li>
<li>仕様が未確定のまま設計（後で崩壊します）</li>
</ul>
<hr>
<h3>Phase 6：実装生成（Implementation）</h3>
<p><strong>目的</strong>：設計に従ってコードを生成します。 <strong>入力</strong>：設計、出力形式ルール、禁止事項 <strong>出力</strong>：ファイル単位のソースコード一式 <strong>合格条件</strong>：コンパイルが通る前提になっている／依存関係が破綻していない</p>
<p><strong>実装生成時の指示に入れると強い項目</strong></p>
<ul>
<li>「ファイル名 → コード全文」の形式で出す</li>
<li>実行手順（コマンド）も併記する</li>
<li>エラー処理方針（再入力、例外握り潰し禁止など）</li>
</ul>
<hr>
<h3>Phase 7：検証（Verification）</h3>
<p><strong>目的</strong>：期待動作を満たすかを確認できる形にします。 <strong>入力</strong>：要件、コード <strong>出力</strong>：テスト観点、手動テスト手順、テストケース表 <strong>合格条件</strong>：受入条件を網羅する／異常系が含まれる</p>
<p><strong>補足</strong></p>
<ul>
<li>ここは「AIにテストを書かせる」だけでも価値があります。</li>
<li>実行して確かめるのは人間の仕事です（AIは実行環境を持たない前提が多いので、ここを誤解すると詰みます）。</li>
</ul>
<hr>
<h3>Phase 8：レビューと改善（Review）</h3>
<p><strong>目的</strong>：品質の穴（例外、境界値、保守性）を潰します。 <strong>入力</strong>：コード、テスト結果、気づき <strong>出力</strong>：改善提案、リスク、修正方針 <strong>合格条件</strong>：修正対象が具体化されている／修正後の期待動作が書かれている</p>
<p><strong>レビュー観点（最低限）</strong></p>
<ul>
<li>入力バリデーションは十分か</li>
<li>例外で落ちないか</li>
<li>仕様と表示文言が一致しているか</li>
<li>変更しやすい構造か（責務分離）</li>
</ul>
<hr>
<h3>Phase 9：変更管理しながら反復（Change Control）</h3>
<p><strong>目的</strong>：「直して」を卒業して、差分管理で品質を上げます。 <strong>入力</strong>：変更要求（何を/なぜ/どこまで） <strong>出力</strong>：差分修正、変更理由、影響範囲、再テスト項目 <strong>合格条件</strong>：変更理由が説明され、影響範囲が明記されている</p>
<p><strong>変更要求テンプレ（これだけで事故が減ります）</strong></p>
<ul>
<li>変更目的：</li>
<li>変更内容（Before/After）：</li>
<li>変更禁止事項（触るなリスト）：</li>
<li>受入条件（再テスト）：</li>
</ul>
<hr>
<h3>Phase 10：資産化（Assetization）</h3>
<p><strong>目的</strong>：会話を“開発資産”に変えます。 <strong>入力</strong>：各フェーズのプロンプト、成果物 <strong>出力</strong>：プロンプト・成果物・変更履歴の保存 <strong>合格条件</strong>：別の人でも再現できる状態になっている</p>
<p><strong>推奨の保存単位</strong></p>
<ul>
<li><code>PROMPT_00_BASELINE.md</code></li>
<li><code>PROMPT_01_SCOPE.md</code></li>
<li><code>PROMPT_02_REQUIREMENTS.md</code></li>
<li><code>PROMPT_03_ASSUMPTIONS.md</code></li>
<li><code>PROMPT_04_DESIGN.md</code></li>
<li><code>PROMPT_05_IMPLEMENTATION.md</code></li>
<li><code>PROMPT_06_TEST.md</code></li>
<li><code>PROMPT_07_REVIEW.md</code></li>
<li><code>PROMPT_08_CHANGELOG.md</code></li>
</ul>
<hr>
<h2>4. ミスが起きやすいポイント（先回りチェック）</h2>
<p>プロンプトプログラミングでよく起きる失敗はだいたい次の4つです。</p>
<ol>
<li><strong>要件が曖昧なまま実装に入る</strong></li>
<li><strong>仮定を固定せず、AIが推測で埋める</strong></li>
<li><strong>修正指示が雑で、別の場所が壊れる</strong></li>
<li><strong>プロンプトを保存せず、再現できない</strong></li>
</ol>
<p>上のフローは、これらを潰すように作っています。</p>
<hr>
<h2>5. まとめ（最短で正しく回すコツ）</h2>
<ul>
<li>まず <strong>基本ルール</strong>を固定します</li>
<li>次に <strong>要件</strong>を文章で確定します</li>
<li><strong>仮定</strong>を明示してブレを潰します</li>
<li><strong>設計 → 実装 → 検証</strong>の順を守ります</li>
<li>修正は <strong>差分・理由・影響範囲</strong>で回します</li>
<li>最後に <strong>プロンプトを資産化</strong>します</li>
</ul>
<p>この運用ができると、プロンプトプログラミングは「速い」だけでなく <strong>壊れにくく、引き継げる開発手法</strong>になります。</p>
    </section>
    <section>
<h1 id="chapter-3">プロンプトプログラミング：工程別テンプレート集（コピペ用）</h1>
<ul>
<li>目的：あなたが提示した標準フロー（1〜10）を、<strong>毎回ブレずに回せる</strong>ようにするための「工程別プロンプト」を用意します。</li>
<li>使い方：各工程で、該当テンプレを貼り付けて <code>&lt;&lt; &gt;&gt;</code> を埋めて使います。</li>
<li>記法：</li>
<ul>
<li><code>&lt;&lt;あなたが埋める&gt;&gt;</code>：あなたの入力欄</li>
<li><code>&lt;&lt;AIが出すべき&gt;&gt;</code>：AI出力の指示</li>
<li>注意：このテンプレは「AIに出させる」ための文です。あなたが書くのは <code>&lt;&lt; &gt;&gt;</code> の中だけでOKです（ラクして勝ちます）。</li>
</ul>
</ul>


<h2>1. 基本ルール固定（Baseline）テンプレ</h2>
<p><strong>ファイル名例：<code><a href="../project-root/template-project/prompts/PROMPT_00_BASELINE.md">PROMPT_00_BASELINE.md</a></code></strong></p>
<pre><code class="language-text">
あなたは開発支援AIです。これから「プロンプトプログラミング」で開発を進めます。
以下の基本ルールは、以後の全工程に適用します。矛盾がないように整理し、最終版を出力してください。

基本ルール（PROMPT_00_BASELINE）に厳密に従ってください。
不明点は推測で埋めず、「要確認」として止めてください。
出力は指定フォーマットに従い、省略しないでください。

【目的】
- 基本ルール（禁止事項・制約・出力形式・品質基準）を固定して、以後の出力ブレを防ぎます。

【前提（あなたの役割）】
- 私はコードを直接編集しません（必要なら修正指示を出します）。
- あなたは設計・実装・テスト観点・修正案を生成します。

【基本ルール（埋めてください）】
- 使用言語：&lt;&lt;例：Java&gt;&gt;
- 想定レベル：&lt;&lt;例：Bronze範囲&gt;&gt;
- 禁止事項：
  - &lt;&lt;例：DB使用禁止 / Web使用禁止 / 外部API禁止 / ネットワーク通信禁止&gt;&gt;
- 許可事項：
  - &lt;&lt;例：標準ライブラリのみ / ファイル保存は許可 など&gt;&gt;
- 出力形式：
  - &lt;&lt;例：ファイル単位で「ファイル名 → コード全文」&gt;&gt;
  - &lt;&lt;例：コードは省略しない&gt;&gt;
- 品質基準：
  - &lt;&lt;例：入力バリデーション必須 / 例外で即終了しない / 再入力誘導&gt;&gt;
- 命名・スタイル：
  - &lt;&lt;例：クラスはUpperCamel / メソッドはlowerCamel / コメント最小&gt;&gt;
- 実行環境：
  - &lt;&lt;例：コンソール / Java 17&gt;&gt;

【あなたへの指示】
1) 上記を「基本ルールプロンプト（最終版）」として読みやすく整形してください。
2) 矛盾や不足があれば「矛盾/不足リスト」を出してください（推測で勝手に補完しない）。
3) 最後に「この基本ルールを以後の工程で参照します」と明記してください。

【出力形式】
- セクション1：基本ルールプロンプト（最終版）
- セクション2：矛盾/不足リスト（あれば）
</code></pre>

<h2>2. 目的・範囲の確定（Scope）テンプレ</h2>
<p><strong>ファイル名例：<code><a href="../project-root/template-project/prompts/PROMPT_01_SCOPE.md">PROMPT_01_SCOPE.md</a></code></strong></p>
<pre><code class="language-text">

<p>あなたは開発支援AIです。以下の情報から、成果物の目的とスコープ（in/out）を確定します。 基本ルールは別紙（PROMPT_00_BASELINE）に従ってください。</p>
<p>基本ルール（PROMPT_00_BASELINE）に厳密に従ってください。 不明点は推測で埋めず、「要確認」として止めてください。 出力は指定フォーマットに従い、省略しないでください。</p>
<p>【目的】</p>
<ul>
<li>「何を作る/作らない」を固定して、後工程の迷走を防ぎます。</li>
</ul>
<p>【成果物の概要（埋めてください）】</p>
<ul>
<li>アプリ名：&lt;&lt; &gt;&gt;</li>
<li>目的：&lt;&lt; &gt;&gt;</li>
<li>想定ユーザー：&lt;&lt; &gt;&gt;</li>
<li>実行形態：&lt;&lt;例：コンソール / Swing&gt;&gt;</li>
<li>利用シーン：&lt;&lt; &gt;&gt;</li>
</ul>
<p>【スコープ候補（埋めてください）】</p>
<ul>
<li>In scope（作ること）：</li>
<ul>
<li>&lt;&lt;例：メニュー / 入力 / 結果表示 / 戦績表示&gt;&gt;</li>
<li>Out of scope（作らないこと）：</li>
<li>&lt;&lt;例：ネット対戦 / オンラインランキング / 画像演出&gt;&gt;</li>
</ul>
</ul>
<p>【あなたへの指示】</p>
<ol>
<li>上記を整理して「スコープ定義（最終版）」を作ってください。</li>
<li>In/Outの境界が曖昧な点があれば「要確認」にして列挙してください（勝手に決めない）。</li>
<li>最後に「完成の定義（Done）」を1〜3行で書いてください。</li>
</ol>
<p>【出力形式】</p>
<ul>
<li>スコープ定義（最終版）</li>
<li>要確認リスト（あれば）</li>
<li>完成の定義（Done）</li>
</ul>
</code></pre>

<h2>3. 要件定義（Requirements）テンプレ</h2>
<p><strong>ファイル名例：<code>PROMPT_02_REQUIREMENTS.md</code></strong></p>
<pre><code class="language-text">
あなたは開発支援AIです。以下の情報から要件定義を作成します。
基本ルール（PROMPT_00）とスコープ（PROMPT_01）に従ってください。

基本ルール（PROMPT_00_BASELINE）に厳密に従ってください。
不明点は推測で埋めず、「要確認」として止めてください。
出力は指定フォーマットに従い、省略しないでください。

【目的】
- 実装が迷わない粒度で「機能要件/非機能要件/入出力/例外時」を文章化します。

【入力（埋めてください）】
- 作りたい機能（箇条書き）：&lt;&lt; &gt;&gt;
- 画面・操作（コンソールならメニュー遷移）：&lt;&lt; &gt;&gt;
- 入力形式：&lt;&lt;例：g/c/p、数字メニューなど&gt;&gt;
- 出力形式：&lt;&lt;例：結果文言、一覧表示&gt;&gt;
- 永続化：&lt;&lt;例：なし / ファイル保存あり（CSV）&gt;&gt;
- 例外・不正入力：&lt;&lt;例：再入力させる、エラーメッセージ&gt;&gt;

【あなたへの指示】
1) 機能要件（FR）を番号付きで整理してください。
2) 非機能要件（NFR：品質/制約/運用）を整理してください。
3) 入力仕様（許容/禁止/再入力）と出力仕様（表示項目）を明文化してください。
4) 受入条件（Acceptance Criteria）を「テスト可能な文」で5〜10個作ってください。
5) 曖昧な点は「要確認」に分離してください（推測で埋めない）。

【出力形式】
- 機能要件（FR）
- 非機能要件（NFR）
- 入力仕様 / 出力仕様
- 受入条件（Acceptance Criteria）
- 要確認リスト（あれば）

</code></pre>


<h2> 4. 仮定と未決定事項の固定（Assumptions）テンプレ</h2>
**ファイル名例：`PROMPT_03_ASSUMPTIONS.md`**

<pre><code class="language-text">
<p>あなたは開発支援AIです。要件定義を読んだ上で、仮定と未決定事項を整理します。 基本ルール（PROMPT_00）と要件定義（PROMPT_02）に従ってください。</p>
<p>基本ルール（PROMPT_00_BASELINE）に厳密に従ってください。 不明点は推測で埋めず、「要確認」として止めてください。 出力は指定フォーマットに従い、省略しないでください。</p>
<p>【目的】</p>
<ul>
<li>仕様の空白をAIが勝手に補完してブレるのを防ぎます。</li>
</ul>
<p>【入力（埋めてください）】</p>
<ul>
<li>要件定義（貼り付け or 箇条書き）：&lt;&lt; &gt;&gt;</li>
</ul>
<p>【あなたへの指示】</p>
<ol>
<li>要件定義から、仕様が未確定な点を抽出して「未決定事項（Open Issues）」に列挙してください。</li>
<li>仕様の空白を埋める必要がある点は「仮定（Assumptions）」として提案してください。</li>
<li>仮定は、できれば「選択肢A/B」とそれぞれのメリット・デメリットを付けてください。</li>
<li>最後に「推奨案」を出してください。ただし決定は私がします（勝手に確定しない）。</li>
</ol>
<p>【出力形式】</p>
<ul>
<li>未決定事項（Open Issues）</li>
<li>仮定案（Assumptions：選択肢付き）</li>
<li>推奨案（理由付き）</li>
</ul>
</code></pre>

<h2>5. 設計（Design）テンプレ</h2>
<p><strong>ファイル名例：<code>PROMPT_04_DESIGN.md</code></strong></p>
<pre><code class="language-text">
あなたは開発支援AIです。以下の情報を前提に設計を作成します。
基本ルール（PROMPT_00）、要件（PROMPT_02）、仮定（PROMPT_03）に従ってください。

基本ルール（PROMPT_00_BASELINE）に厳密に従ってください。
不明点は推測で埋めず、「要確認」として止めてください。
出力は指定フォーマットに従い、省略しないでください。

【目的】
- コード生成の前に、構造（責務分割・データ構造・処理フロー）を固めます。

【入力（埋めてください）】
- 要件定義：&lt;&lt; &gt;&gt;
- 確定した仮定（Assumptionsの中で採用したもの）：&lt;&lt; &gt;&gt;

【あなたへの指示】
1) モジュール/クラス一覧を作り、各責務を1〜3行で説明してください。
2) 主要メソッド一覧（引数・戻り値・例外方針も簡単に）を出してください。
3) データ構造（List/Map/配列など）と理由を書いてください。
4) 主要な処理フロー（メニュー→入力→判定→表示など）を手順で書いてください。
5) 「要件→設計対応表」を作り、要件の抜けがないか自己チェックしてください。
6) 最後に、実装生成に入る前の「確認ポイント」を列挙してください。

【出力形式】
- クラス/モジュール設計
- 主要メソッド設計
- データ構造
- 処理フロー
- 要件→設計対応（抜けチェック）
- 実装前確認ポイント

</code></pre>




<h2>6. 実装生成（Implementation）テンプレ</h2>
**ファイル名例：`PROMPT_05_IMPLEMENTATION.md`**
<pre><code class="language-text">
<p>あなたは開発支援AIです。確定した設計に基づき実装を生成します。 基本ルール（PROMPT_00）と設計（PROMPT_04）に厳密に従ってください。</p>
<p>基本ルール（PROMPT_00_BASELINE）に厳密に従ってください。 不明点は推測で埋めず、「要確認」として止めてください。 出力は指定フォーマットに従い、省略しないでください。</p>
<p>【目的】</p>
<ul>
<li>設計に沿ったコード一式を、ファイル単位で生成します。</li>
</ul>
<p>【入力（埋めてください）】</p>
<ul>
<li>設計（クラス構成・責務・メソッド）：&lt;&lt; &gt;&gt;</li>
<li>実行形態：&lt;&lt;例：コンソール&gt;&gt;</li>
<li>永続化：&lt;&lt;例：なし / CSV保存&gt;&gt;</li>
</ul>
<p>【あなたへの指示】</p>
<ol>
<li>ファイル構成を最初に提示してください（例：Main.java, Game.java...）。</li>
<li>次に、各ファイルを「ファイル名 → コード全文」で順に出してください（省略禁止）。</li>
<li>入力バリデーションと再入力は必須です。</li>
<li>実行手順（コンパイル/実行コマンド）を最後に書いてください。</li>
<li>外部依存（DB/Web/外部API）は使わないでください。</li>
</ol>
<p>【出力形式】</p>
<ul>
<li>ファイル構成</li>
<li>各ファイル：ファイル名 → コード全文</li>
<li>実行手順</li>
</ul>
</code></pre>


<h2>7. 検証（Verification）テンプレ</h2>
<p><strong>ファイル名例：<code><a href="template-project/prompts/PROMPT_06_VERIFICATION.md">PROMPT_06_VERIFICATION.md</a></code></strong></p>
<pre><code class="language-text">
あなたはテスト設計担当です。要件と実装を前提に、検証手順を作成します。
基本ルール（PROMPT_00）と要件（PROMPT_02）に従ってください。

基本ルール（PROMPT_00_BASELINE）に厳密に従ってください。
不明点は推測で埋めず、「要確認」として止めてください。
出力は指定フォーマットに従い、省略しないでください。

【目的】
- 受入条件を満たすかを確認できる手順・ケースを作ります。

【入力（埋めてください）】
- 要件定義（Acceptance Criteria含む）：&lt;&lt; &gt;&gt;
- 実装コード（貼れる範囲でOK）：&lt;&lt; &gt;&gt;
- 実行形態：&lt;&lt;例：コンソール&gt;&gt;

【あなたへの指示】
1) テスト観点を列挙してください（機能/入力異常/境界/表示/状態など）。
2) 手動テスト手順を「操作→期待結果」で書いてください。
3) テストケースを表形式（ID、前提、入力、期待結果、備考）で10〜20件作ってください。
4) 受入条件とテストケースの対応を確認し、抜けがあれば追加してください。

【出力形式】
- テスト観点一覧
- 手動テスト手順
- テストケース一覧（表）
- 受入条件→テスト対応チェック
</code></pre>





<h2>8. レビューと改善（Review）テンプレ</h2>
**ファイル名例：`PROMPT_07_REVIEW.md`**

<pre><code class="language-text">
<p>あなたはコードレビュアーです。要件と実装を照合して、改善点を指摘します。 基本ルール（PROMPT_00）と要件（PROMPT_02）に従ってください。</p>
<p>基本ルール（PROMPT_00_BASELINE）に厳密に従ってください。 不明点は推測で埋めず、「要確認」として止めてください。 出力は指定フォーマットに従い、省略しないでください。</p>
<p>【目的】</p>
<ul>
<li>仕様ズレ、例外、入力、保守性などの穴を潰します。</li>
</ul>
<p>【入力（埋めてください）】</p>
<ul>
<li>要件定義：&lt;&lt; &gt;&gt;</li>
<li>実装コード：&lt;&lt; &gt;&gt;</li>
<li>テスト結果（あれば）：&lt;&lt; &gt;&gt;</li>
</ul>
<p>【あなたへの指示】</p>
<ol>
<li>仕様ズレがないか確認し、あれば「ズレの内容」と「修正方針」を出してください。</li>
<li>入力バリデーション・例外・境界値の弱点を指摘してください。</li>
<li>保守性（責務分離、命名、重複）の改善案を出してください。</li>
<li>改善の優先度を「高/中/低」で分類してください。</li>
<li>最後に「次の変更指示（Change Request）の形」に整形してください。</li>
</ol>
<p>【出力形式】</p>
<ul>
<li>指摘一覧（優先度付き）</li>
<li>修正方針（差分の方向性）</li>
<li>次の変更指示（Change Requestドラフト）</li>
</ul>
</code>
</pre>

<h2>9. 変更管理しながら反復（Change Control）テンプレ</h2>
<p><strong>ファイル名例：<code>PROMPT_08_CHANGE_CONTROL.md</code></strong></p>
<pre><code class="language-text">
あなたは実装担当です。以下の変更指示に従って修正してください。
基本ルール（PROMPT_00）に従い、変更理由と影響範囲も説明してください。

基本ルール（PROMPT_00_BASELINE）に厳密に従ってください。
不明点は推測で埋めず、「要確認」として止めてください。
出力は指定フォーマットに従い、省略しないでください。

【目的】
- 「直して」ではなく、差分・理由・影響範囲で安全に改修します。

【変更指示（埋めてください）】
- 変更目的：&lt;&lt; &gt;&gt;
- 変更内容（Before/After）：&lt;&lt; &gt;&gt;
- 変更対象ファイル：&lt;&lt; &gt;&gt;
- 変更禁止事項（触らない部分）：&lt;&lt; &gt;&gt;
- 期待する挙動（受入条件）：&lt;&lt; &gt;&gt;
- 追加/更新したいテスト：&lt;&lt; &gt;&gt;

【入力（埋めてください）】
- 現在のコード：&lt;&lt; &gt;&gt;
- 現在の要件（必要なら）：&lt;&lt; &gt;&gt;

【あなたへの指示】
1) 変更点を整理して「修正計画（短く）」を出してください。
2) 次に修正版コードをファイル単位で提示してください（変更がないファイルは省略可）。
3) 変更理由、影響範囲、再テスト項目を明記してください。
4) 仕様や基本ルールに反する変更はしないでください（必要なら要確認として止める）。

【出力形式】
- 修正計画
- 修正版コード（ファイル単位）
- 変更理由 / 影響範囲 / 再テスト項目
- 要確認（あれば）
</code></pre>




<h2> 10. 資産化（Assetization）テンプレ</h2>
**ファイル名例：`PROMPT_09_ASSETIZATION.md`**
<pre><code class="language-text">
<p>あなたはドキュメント担当です。ここまでの成果物を「再現できる開発資産」にまとめます。 基本ルール（PROMPT_00）に従ってください。</p>
<p>基本ルール（PROMPT_00_BASELINE）に厳密に従ってください。 不明点は推測で埋めず、「要確認」として止めてください。 出力は指定フォーマットに従い、省略しないでください。</p>
<p>【目的】</p>
<ul>
<li>会話を終わらせず、次回も同じ型で回せるように資産化します。</li>
</ul>
<p>【入力（埋めてください）】</p>
<ul>
<li>基本ルール：&lt;&lt; &gt;&gt;</li>
<li>スコープ：&lt;&lt; &gt;&gt;</li>
<li>要件定義：&lt;&lt; &gt;&gt;</li>
<li>仮定/未決定：&lt;&lt; &gt;&gt;</li>
<li>設計：&lt;&lt; &gt;&gt;</li>
<li>実装：&lt;&lt; &gt;&gt;</li>
<li>テスト：&lt;&lt; &gt;&gt;</li>
<li>変更履歴：&lt;&lt; &gt;&gt;</li>
</ul>
<p>【あなたへの指示】</p>
<ol>
<li>以下のファイル構成で「保存すべき内容」を整形してください。</li>
<li>README（概要、実行方法、仕様、制約、テスト方法）を作ってください。</li>
<li>CHANGELOG（変更理由・影響範囲・対応テスト）を整理してください。</li>
<li>最後に「次回このプロジェクトを再開するための手順」を短く書いてください。</li>
</ol>
<p>【出力形式（提案）】</p>
<ul>
<li>PROMPT_00_BASELINE.md</li>
<li>PROMPT_01_SCOPE.md</li>
<li>PROMPT_02_REQUIREMENTS.md</li>
<li>PROMPT_03_ASSUMPTIONS.md</li>
<li>PROMPT_04_DESIGN.md</li>
<li>PROMPT_05_IMPLEMENTATION.md</li>
<li>PROMPT_06_VERIFICATION.md</li>
<li>PROMPT_07_REVIEW.md</li>
<li>PROMPT_08_CHANGE_CONTROL.md</li>
<li>PROMPT_09_ASSETIZATION.md</li>
<li>README.md</li>
<li>CHANGELOG.md</li>
</ul>
</pre></section>
<section>
<p>おまけ：毎回貼る「共通ヘッダー（任意）」</p>
<p>「毎回ルールを貼るの面倒問題」を解決するためのショート版です。</p>
<p>基本ルール（PROMPT_00_BASELINE）に厳密に従ってください。 不明点は推測で埋めず、「要確認」として止めてください。 出力は指定フォーマットに従い、省略しないでください。</p>
    </section>
  </main>
  </div>
</body>
</html>
