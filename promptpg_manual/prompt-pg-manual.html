<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>プロンプトプログラミングマニュアル</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #fafafa;
      --surface: #ffffff;
      --text: #222222;
      --muted: #5f6368;
      --accent: #1b5e20;
      --border: #e0e0e0;
      --code-bg: #f3f4f6;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo", sans-serif;
      line-height: 1.7;
      color: var(--text);
      background: var(--bg);
    }

    .layout {
      width: 100%;
      margin: 0;
      padding: 16px 2vw;
      display: grid;
      grid-template-columns: 240px 1fr;
      gap: 16px;
    }

    .toc {
      position: sticky;
      top: 16px;
      align-self: start;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px 14px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.06);
    }

    .toc h2 {
      margin: 0 0 8px;
      font-size: 16px;
      color: var(--muted);
    }

    .toc ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .toc li {
      margin: 6px 0;
    }

    .toc a {
      color: var(--text);
      text-decoration: none;
      display: block;
      padding: 6px 8px;
      border-radius: 6px;
    }

    .toc a:hover,
    .toc a:focus {
      background: var(--code-bg);
    }

    main {
      max-width: none;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }

    section {
      margin: 0 0 16px;
      padding: 24px 20px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.06);
    }

    h1 {
      margin: 0 0 16px;
      font-size: 28px;
      border-left: 6px solid var(--accent);
      padding-left: 12px;
    }

    h2 {
      margin: 24px 0 12px;
      font-size: 22px;
    }

    h3 {
      margin: 20px 0 8px;
      font-size: 18px;
      color: var(--accent);
    }

    p {
      margin: 10px 0;
    }

    ul,
    ol {
      margin: 8px 0 12px 20px;
      padding: 0;
    }

    li {
      margin: 6px 0;
    }

    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: var(--code-bg);
      padding: 0 4px;
      border-radius: 4px;
    }

    pre {
      background: var(--code-bg);
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
      border: 1px solid var(--border);
    }

    pre code {
      background: transparent;
      padding: 0;
    }

    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 24px 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 12px 0 16px;
    }

    th,
    td {
      border: 1px solid var(--border);
      padding: 8px 10px;
      text-align: left;
      vertical-align: top;
    }

    thead th {
      background: var(--code-bg);
    }

    em {
      color: var(--muted);
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .toc {
        position: static;
      }
    }
  </style>
</head>
<body>
  <div class="layout">
  <nav class="toc">
  <h2>目次</h2>
  <ul>
  <li><a href="#chapter-1">VSCode + Codex 拡張機能機能で進めるプロンプトプログラミング運用マニュアル</a></li>
  <li><a href="#chapter-2">01 概要</a></li>
  <li><a href="#chapter-3">02 フォルダ構成と配置場所</a></li>
  <li><a href="#chapter-4">03 テンプレート配置ルール</a></li>
  <li><a href="#chapter-5">04 VSCodeでの運用手順</a></li>
  <li><a href="#chapter-6">05 工程別プロンプト入力ガイド</a></li>
  <li><a href="#chapter-7">06 成果物の保存と資産化</a></li>
  <li><a href="#chapter-8">07 よくある失敗と対策</a></li>
  <li><a href="#chapter-9">08 チェックリスト</a></li>
  </ul>
  </nav>
  <main>
<section>
<h1 id="chapter-1">VSCode + Codex 拡張機能機能で進めるプロンプトプログラミング運用マニュアル</h1>
<p>作成日: 2026-01-11</p>
<p>このマニュアルは、VSCode上で OpenAI Codex 系の拡張機能を使い、<strong>プロンプトプログラミング</strong>を手順化して回すための運用ガイドです。 プロンプト（テンプレート）をプロジェクト内に配置し、工程（Baseline → Assetization）を安定して進めることを目的にしています。</p>
<hr>
<h2>章構成（ファイル一覧）</h2>
<ol>
<li><a href="01_概要.md">01_概要.md</a></li>
<li><a href="02_フォルダ構成と配置場所.md">02_フォルダ構成と配置場所.md</a></li>
<li><a href="03_テンプレート配置ルール.md">03_テンプレート配置ルール.md</a></li>
<li><a href="04_VSCodeでの運用手順.md">04_VSCodeでの運用手順.md</a></li>
<li><a href="05_工程別プロンプト入力ガイド.md">05_工程別プロンプト入力ガイド.md</a></li>
<li><a href="06_成果物の保存と資産化.md">06_成果物の保存と資産化.md</a></li>
<li><a href="07_よくある失敗と対策.md">07_よくある失敗と対策.md</a></li>
<li><a href="08_チェックリスト.md">08_チェックリスト.md</a></li>
</ol>
<hr>
<h2>本マニュアルの前提</h2>
<h2>用語</h2>
<ul>
<li><strong>VSCode拡張機能（Extension）</strong>：VSCodeに追加インストールする機能です。</li>
<p>本マニュアルでは特に、<strong>OpenAI Codex 拡張機能機能（AIコーディング支援）</strong>を指します。</p>
<li><strong>ファイル参照機能</strong>：プロンプト内で特定ファイルを指定し、その内容をAIに読ませる機能です。</li>
<p>有無や書き方は拡張機能の仕様に依存します（例：<code>@ファイル</code>、選択範囲の共有など）。</p>
</ul>
<ul>
<li>コーディングは <strong>VSCode</strong> で行います。</li>
<li>AI支援は <strong>OpenAI Codex 拡張機能（または同等のAIコーディング支援拡張機能）</strong>を使います。</li>
<li>プロンプトは、VSCode内の拡張機能の入力欄（チャット/コマンド/エディタ統合）に入力します。</li>
<li><strong>重要</strong>：AIがローカルの <code>PROMPT_00_BASELINE.md</code> を自動で読めるとは限りません。</li>
<p>そのため、運用としては次のどちらかを必ず行います。</p>
<ul>
<li><strong>プロンプト本文に必要な内容を貼り付ける（最も確実）</strong></li>
<li>使っているVSCode拡張機能が「ファイル参照」機能を持つ場合は、それを明示的に使う（例：@ファイル参照など）</li>
<p>※この機能の有無はVSCode拡張機能の仕様によります。</p>
</ul>
</ul>
<hr>
<h2>最短の結論</h2>
<p>テンプレートファイルは、プロジェクト内に次のように配置するのが分かりやすくて強いです。</p>
<pre><code class="language-text">
your-project/
  prompts/
    PROMPT_00_BASELINE.md
    PROMPT_01_SCOPE.md
    ...
    PROMPT_09_ASSETIZATION.md
  README.md
  CHANGELOG.md
  src/
    ...
</code></pre>
<p>以後の章で、なぜこの配置が良いか、どう使うか、事故らない運用を解説します。</p>
</section>
<section>
<h1 id="chapter-2">01 概要</h1>
<h2>1. このマニュアルが扱うこと</h2>
<p>このマニュアルは、プロンプトプログラミングを <strong>「思いつきの会話」</strong>ではなく、 <strong>工程管理できる開発手法</strong>として運用するための手順をまとめます。</p>
<p>対象は、次のような進め方です。</p>
<ul>
<li>テンプレート（PROMPT_00〜）をプロジェクトに保存します</li>
<li>工程に沿ってプロンプトを入力します</li>
<li>出力（仕様、設計、コード、テスト、変更履歴）をファイルに残します</li>
<li>変更は「差分」「理由」「影響範囲」で管理します</li>
</ul>
<h2>0. 用語（このマニュアル内での意味）</h2>
<ul>
<li><strong>拡張機能</strong>：VSCodeにインストールする追加機能です。本マニュアルでは主に <strong>OpenAI Codex 拡張機能</strong>（AIコーディング支援）を指します。</li>
<li><strong>ファイル参照</strong>：拡張機能が提供する「特定ファイルを文脈に含める」機能です。書き方や対応状況は拡張機能により異なります。</li>
</ul>
<h2>2. ここで言う「プロンプトプログラミング」</h2>
<p>本マニュアルでのプロンプトプログラミングは、次を指します。</p>
<ul>
<li>人間は、主に <strong>仕様・制約・評価基準</strong>を言語化します</li>
<li>AIは、主に <strong>設計・実装・テスト観点・修正案</strong>を生成します</li>
<li>最終的な妥当性判断と責任は <strong>人間</strong>が持ちます</li>
</ul>
<h2>3. なぜテンプレートをプロジェクトに置くのか</h2>
<p>テンプレートをプロジェクト内に置く理由はシンプルです。</p>
<ul>
<li>チームで共有できます（または将来共有できます）</li>
<li>変更履歴を追えます（Gitで差分が見えます）</li>
<li>「どの前提で作ったか」を後から再現できます</li>
</ul>
<p>逆に、テンプレートがチャット履歴にだけある状態は、再現不能になりやすいです。</p>
<h2>4. 重要な注意（必ず理解しておくこと）</h2>
<p>プロンプト内にこう書いても…</p>
<pre><code class="language-text">
基本ルール（PROMPT_00_BASELINE）に厳密に従ってください。
</code></pre>
<p>AIがローカルのファイルを勝手に開いて読むとは限りません。 運用としては、次のどちらかが必要です。</p>
<ul>
<li><strong>PROMPT_00_BASELINE.md の内容を、プロンプト欄に貼る</strong></li>
<li>使用しているVSCode拡張機能（OpenAI Codexなど）がファイル参照機能を持つ場合に限り、<strong>明示的に参照して読ませる</strong></li>
</ul>
<p>この「読み込みの仕組み」を誤解すると、以後の工程が全部ズレます。</p>
</section>
<section>
<h1 id="chapter-3">02 フォルダ構成と配置場所</h1>
<h2>1. 推奨フォルダ構成（標準）</h2>
<p>テンプレートは <code>prompts/</code> にまとめ、READMEとCHANGELOGはルートに置きます。</p>
<pre><code class="language-text">
your-project/
  prompts/
    PROMPT_00_BASELINE.md
    PROMPT_01_SCOPE.md
    PROMPT_02_REQUIREMENTS.md
    PROMPT_03_ASSUMPTIONS.md
    PROMPT_04_DESIGN.md
    PROMPT_05_IMPLEMENTATION.md
    PROMPT_06_VERIFICATION.md
    PROMPT_07_REVIEW.md
    PROMPT_08_CHANGE_CONTROL.md    (変更があれば)
    PROMPT_09_ASSETIZATION.md
  README.md
  CHANGELOG.md
  src/
    (実装コード)
</code></pre>
<h3>こう置くメリット</h3>
<ul>
<li><code>prompts/</code> を見れば「設計・要件」が一箇所に集まる</li>
<li>ルートの README/CHANGELOG は一般的な配置なので迷わない</li>
</ul>
<h2>2. README.md と CHANGELOG.md の役割</h2>
<ul>
<li>README.md</li>
<ul>
<li>プロジェクトの使い方・仕様・制約を説明します（将来の自分に向けた説明でもOK）</li>
<li>CHANGELOG.md</li>
<li>変更理由、影響範囲、再テスト項目を残します</li>
<li>「なぜそうなったか」を追えるようにします</li>
</ul>
</ul>
<h2>3. VSCodeでの作り方（最短）</h2>
<ol>
<li>エクスプローラーでプロジェクトを開きます</li>
<li>ルート直下に <code>prompts/</code> フォルダを作ります</li>
<li><code>prompts/</code> の中に PROMPT_00〜 を作ります</li>
<li>ルートに README.md / CHANGELOG.md を作ります</li>
</ol>
<h2>4. ファイル名のルール（おすすめ）</h2>
<ul>
<li>先頭の番号（00〜09）で順番が固定されます</li>
<li>章番号と工程番号が一致するので、運用が崩れにくいです</li>
</ul>
</section>
<section>
<h1 id="chapter-4">03 テンプレート配置ルール</h1>
<h2>1. 「どこに置けばいいか」の答え</h2>
<p>リストのファイルは、次のように配置します。</p>
<ul>
<li>PROMPT_00〜PROMPT_09：<code>prompts/</code> フォルダ</li>
<li>README.md / CHANGELOG.md：プロジェクト直下（ルート）</li>
</ul>
<p>例：</p>
<pre><code class="language-text">
your-project/
  prompts/
    PROMPT_00_BASELINE.md
    ...
  README.md
  CHANGELOG.md
</code></pre>
<h2>2. PROMPT_00〜PROMPT_09 の意味（運用上の役割）</h2>
<ul>
<li>PROMPT_00_BASELINE.md       ：禁止事項・品質・出力形式など「絶対に守るルール」</li>
<li>PROMPT_01_SCOPE.md          ：やること/やらないこと（in/out）</li>
<li>PROMPT_02_REQUIREMENTS.md   ：要件定義（機能、入力、出力、受入条件）</li>
<li>PROMPT_03_ASSUMPTIONS.md    ：仮定と未決定事項の固定</li>
<li>PROMPT_04_DESIGN.md         ：設計（責務、クラス、データ構造、処理フロー）</li>
<li>PROMPT_05_IMPLEMENTATION.md ：実装生成指示（ファイル単位、省略禁止など）</li>
<li>PROMPT_06_VERIFICATION.md   ：テスト観点・手動テスト手順・テストケース</li>
<li>PROMPT_07_REVIEW.md         ：レビュー観点・改善提案</li>
<li>PROMPT_08_CHANGE_CONTROL.md ：変更管理（差分、理由、影響、再テスト）</li>
<li>PROMPT_09_ASSETIZATION.md   ：資産化（README/CHANGELOG/プロンプトの確定）</li>
</ul>
<h2>3. よくある勘違い（重要）</h2>
<p>プロンプトに「PROMPT_00に従え」と書いても、AIが自動でファイルを読むとは限りません。 なので、運用としては次のどちらかを選びます。</p>
<h3>運用A（確実）：必要な内容を貼り付ける</h3>
<ul>
<li>Baselineを毎回貼る、または Baselineの要点だけ貼る</li>
<li>もっとも確実で、VSCode拡張機能（OpenAI Codexなど）の仕様に依存しません</li>
</ul>
<h3>運用B（便利）：VSCode拡張機能（OpenAI Codexなど）のファイル参照を使う</h3>
<ul>
<li>使っているVSCode拡張機能にファイル参照機能がある場合だけ可能です</li>
<li>例：@ファイル参照、選択範囲を文脈に含める、など</li>
<li>仕様はVSCode拡張機能によって違います（このマニュアルでは「あるかもしれない」扱いで書きます）</li>
</ul>
<h2>4. おすすめ運用（最初はこれ）</h2>
<p>最初は「運用A（貼り付け）」で始めるのがおすすめです。 理由は1つで、事故が少ないからです。</p>
</section>
<section>
<h1 id="chapter-5">04 VSCodeでの運用手順</h1>
<h2>1. 事前準備</h2>
<ul>
<li><code>prompts/</code> フォルダを作り、PROMPT_00〜PROMPT_09 を置きます</li>
<li>README.md / CHANGELOG.md を置きます</li>
<li>実装用の <code>src/</code>（または任意のディレクトリ）を用意します</li>
</ul>
<h2>2. VSCode上での基本運用（工程を回す）</h2>
<p>基本は「テンプレを開く → 必要部分を埋める → Codex入力欄に貼る」です。</p>
<h3>手順（例：PROMPT_01_SCOPE）</h3>
<ol>
<li><code>prompts/PROMPT_01_SCOPE.md</code> を開きます</li>
<li><code>&lt;&lt; &gt;&gt;</code> のような穴埋めがあれば埋めます（または追記します）</li>
<li>その内容を Codex の入力欄へ貼ります</li>
<li>出力を受け取ったら、結果を <code>prompts/</code> か <code>docs/</code> に保存します（次工程で参照するため）</li>
</ol>
<h2>3. 「Baselineを守らせる」現実的な方法</h2>
<h3>方法A：Baseline全文を一緒に貼る（最強・確実）</h3>
<ul>
<li>PROMPT_00 の内容を、各プロンプトの先頭に貼ります</li>
<li>長い場合は、要点だけ抜粋して貼ってもOKです（禁止事項、出力形式、品質基準は残す）</li>
</ul>
<h3>方法B：Baselineファイルを開いた状態にしてから依頼する</h3>
<ul>
<li>一部のVSCode拡張機能（AIコーディング支援拡張機能）は、開いているファイルや選択範囲を文脈として使います</li>
<li>ただし確実性はVSCode拡張機能の仕様に依存します</li>
<p>→ 事故りたくないなら、方法Aに戻します</p>
</ul>
<h2>4. 出力が長くて省略される場合</h2>
<p>「省略しないで」と書いても、モデルの都合で途中で切れることがあります。 その場合は、次の運用が現実的です。</p>
<ul>
<li>「続き」と言って続編を出させます</li>
<li>もしくは「ファイルを1つずつ出して」と分割させます</li>
<li>もしくは「まずファイル構成だけ」「次に1ファイル目」…と段階的に出させます</li>
</ul>
<h2>5. 変更（改修）時の運用</h2>
<p>雑に「直して」だと壊れます。 必ず PROMPT_08_CHANGE_CONTROL の形（差分、理由、影響、再テスト）で指示します。</p>
</section>
<section>
<h1 id="chapter-6">05 工程別プロンプト入力ガイド</h1>
<p>ここでは「どの工程で、何をCodexに入力すればよいか」を簡潔にまとめます。</p>
<h2>1. 工程の回し方（基本）</h2>
<ol>
<li>PROMPT_00：基本ルールを確定する（以後の前提）</li>
<li>PROMPT_01：スコープを確定する（in/out）</li>
<li>PROMPT_02：要件定義を作る（受入条件まで）</li>
<li>PROMPT_03：仮定と未決定事項を固定する</li>
<li>PROMPT_04：設計を作る（責務・メソッド・フロー）</li>
<li>PROMPT_05：実装を生成する（ファイル単位）</li>
<li>PROMPT_06：テストを作る（手動手順・ケース）</li>
<li>PROMPT_07：レビューする（ズレと改善）</li>
<li>PROMPT_08：変更管理で改修する（必要時）</li>
<li>PROMPT_09：資産化（README/CHANGELOG確定）</li>
</ol>
<h2>2. 工程ごとの「入力」と「期待出力」</h2>
<h3>PROMPT_00（Baseline）</h3>
<ul>
<li>入力：禁止事項、出力形式、品質基準</li>
<li>出力：最終版Baseline（矛盾があれば指摘）</li>
</ul>
<h3>PROMPT_01（Scope）</h3>
<ul>
<li>入力：何を作る/作らない</li>
<li>出力：in/out、Done定義</li>
</ul>
<h3>PROMPT_02（Requirements）</h3>
<ul>
<li>入力：機能、入力、出力、不正入力時の挙動</li>
<li>出力：FR/NFR、受入条件、要確認</li>
</ul>
<h3>PROMPT_03（Assumptions）</h3>
<ul>
<li>入力：決めたい仮定、未決定</li>
<li>出力：仮定の最終版、Open Issues、推奨案（確定は人間）</li>
</ul>
<h3>PROMPT_04（Design）</h3>
<ul>
<li>入力：要件＋仮定</li>
<li>出力：クラス責務、主要メソッド、データ構造、処理フロー、要件対応チェック</li>
</ul>
<h3>PROMPT_05（Implementation）</h3>
<ul>
<li>入力：設計</li>
<li>出力：ファイル構成＋各ファイルのコード全文＋実行手順</li>
</ul>
<h3>PROMPT_06（Verification）</h3>
<ul>
<li>入力：要件＋実装（または要点）</li>
<li>出力：テスト観点、手動テスト、テストケース表、抜けチェック</li>
</ul>
<h3>PROMPT_07（Review）</h3>
<ul>
<li>入力：要件＋設計＋実装＋（あればテスト結果）</li>
<li>出力：指摘（優先度付き）、修正方針、Change Request下書き</li>
</ul>
<h3>PROMPT_08（Change Control）</h3>
<ul>
<li>入力：差分、理由、影響、再テスト、現在コード</li>
<li>出力：修正計画、修正版コード、影響範囲、再テスト</li>
</ul>
<h3>PROMPT_09（Assetization）</h3>
<ul>
<li>入力：各工程の確定版</li>
<li>出力：保存ファイル一式の整形、README、CHANGELOG、再開手順</li>
</ul>
<h2>3. 「推測で埋めない」を守らせるコツ</h2>
<ul>
<li>「曖昧な点は要確認に分離」と明記します</li>
<li>「勝手に決めず、選択肢で出す」と書きます</li>
<li>仕様が確定していない部分は、仮定（Assumptions）で固定してから次工程へ進みます</li>
</ul>
</section>
<section>
<h1 id="chapter-7">06 成果物の保存と資産化</h1>
<h2>1. 何を保存すべきか</h2>
<p>最低限、次を保存します。</p>
<ul>
<li>PROMPT_00〜PROMPT_09（実際に使った版）</li>
<li>生成された設計・要件（出力物）</li>
<li>実装コード（src/）</li>
<li>README.md</li>
<li>CHANGELOG.md</li>
</ul>
<h2>2. 「保存しておくと強い」追加物</h2>
<ul>
<li>テスト結果（手動テストの実施ログ）</li>
<li>既知の制限（できていないこと）</li>
<li>次にやるべき改善メモ（Backlog）</li>
</ul>
<h2>3. CHANGELOG の書き方（最小形）</h2>
<p>変更が発生したら、1件につきこれだけ書くと十分です。</p>
<ul>
<li>変更内容（何を変えたか）</li>
<li>変更理由（なぜ変えたか）</li>
<li>影響範囲（どこが変わるか）</li>
<li>再テスト項目（どれを確認したか）</li>
</ul>
<h2>4. 資産化のゴール（Done）</h2>
<p>「1か月後の自分」が、次を見て復元できる状態になっていれば成功です。</p>
<ul>
<li>何を作ったか（README）</li>
<li>どう動かすか（README）</li>
<li>どの前提で作ったか（PROMPT_00〜）</li>
<li>何が変わったか（CHANGELOG）</li>
</ul>
</section>
<section>
<h1 id="chapter-8">07 よくある失敗と対策</h1>
<h2>1. 失敗：AIがBaselineを無視する</h2>
<h3>原因</h3>
<ul>
<li>Baselineを参照させたつもりでも、AIが実際には読めていない</li>
</ul>
<h3>対策</h3>
<ul>
<li>Baselineの要点（禁止事項・出力形式・品質）をプロンプト本文に貼ります</li>
<li>「違反した場合は要確認として止める」と書きます</li>
</ul>
<h2>2. 失敗：勝手に仕様を埋める</h2>
<h3>原因</h3>
<ul>
<li>要件の空白があると、AIはそれっぽい仮定で埋めがち</li>
</ul>
<h3>対策</h3>
<ul>
<li>PROMPT_03（Assumptions）を必ず挟みます</li>
<li>「曖昧な点は要確認に分離」と明記します</li>
</ul>
<h2>3. 失敗：実装が長くて途中で切れる</h2>
<h3>対策</h3>
<ul>
<li>「ファイルを1つずつ出して」と依頼します</li>
<li>先にファイル構成だけ出して、次に各ファイルへ進みます</li>
<li>切れたら「続き」を要求します</li>
</ul>
<h2>4. 失敗：修正で別のところが壊れる</h2>
<h3>原因</h3>
<ul>
<li>変更指示が雑（差分・理由・影響がない）</li>
</ul>
<h3>対策</h3>
<ul>
<li>PROMPT_08（Change Control）形式で指示します</li>
<li>「触るなリスト（変更禁止事項）」を必ず書きます</li>
</ul>
<h2>5. 失敗：Mainに全部詰め込まれる</h2>
<h3>対策</h3>
<ul>
<li>PROMPT_04（Design）で責務分割を固定してから実装生成します</li>
<li>「Mainは起動とメニュー、ロジックは別クラス」と明記します</li>
</ul>
</section>
<section>
<h1 id="chapter-9">08 チェックリスト</h1>
<h2>1. 開始前チェック（プロジェクト準備）</h2>
<ul>
<li>[ ] <code>prompts/</code> フォルダを作った</li>
<li>[ ] PROMPT_00〜PROMPT_09 を置いた</li>
<li>[ ] README.md / CHANGELOG.md をルートに置いた</li>
<li>[ ] 実装用のフォルダ（例：src/）がある</li>
</ul>
<h2>2. 工程チェック（進行）</h2>
<ul>
<li>[ ] PROMPT_00：禁止事項・出力形式・品質が明確</li>
<li>[ ] PROMPT_01：in/out と Done が明確</li>
<li>[ ] PROMPT_02：受入条件がテスト可能な文になっている</li>
<li>[ ] PROMPT_03：仮定が固定され、未決定が分離されている</li>
<li>[ ] PROMPT_04：要件→設計対応チェックがある</li>
<li>[ ] PROMPT_05：ファイル単位でコードが出ている（省略なし）</li>
<li>[ ] PROMPT_06：異常系を含むテストがある</li>
<li>[ ] PROMPT_07：優先度付きの改善提案がある</li>
<li>[ ] PROMPT_08：変更は差分・理由・影響・再テストで管理</li>
<li>[ ] PROMPT_09：README/CHANGELOG まで整った</li>
</ul>
<h2>3. 最終チェック（資産化）</h2>
<ul>
<li>[ ] READMEに「実行方法」と「仕様」が書いてある</li>
<li>[ ] CHANGELOGに変更理由と再テストが残っている</li>
<li>[ ] プロンプト（PROMPT_00〜）がプロジェクト内に残っている</li>
</ul>
</section>
  </main>
</div>
</body>
</html>
