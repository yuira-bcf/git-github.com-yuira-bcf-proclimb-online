#使い方（最短手順）

1.PROMPT_00_BASELINE.md を貼って、AIから「最終版Baseline」を得ます
2.続けて PROMPT_01_SCOPE.md → PROMPT_02_REQUIREMENTS.md → PROMPT_03_ASSUMPTIONS.md → PROMPT_04_DESIGN.md
3.PROMPT_05_IMPLEMENTATION.md でコード一式を出させます
4.PROMPT_06_VERIFICATION.md でテストを出させます
5.必要なら PROMPT_07_REVIEW.md → PROMPT_08_CHANGE_CONTROL.md で改修します
6.最後に PROMPT_09_ASSETIZATION.md で README/CHANGELOG まで固めます

---

## 1.PROMPT_00_BASELINE.md を貼って、AIから「最終版Baseline」を得ます

    「最終版Baseline」は “以後ずっと守らせるルールの正本（Single Source of Truth）” なので、扱いは 設定ファイルと同じにします。
    結論から言うと、保存先は 2段構えが一番安定します。

    ### 1) 最終版Baselineのおすすめ保存先（結論）
        保存先A（正本）
        prompts/PROMPT_00_BASELINE.md
        → Baselineの全文（詳細版）をここに固定します。Git管理の対象です。

        保存先B（Codexに“自動で効かせる用”）
        リポジトリ直下の AGENTS.md
        → **短い要約版（守るべき要点だけ）**を書きます。
        Codexはプロジェクト内の AGENTS.md を探索してガイドとして使う設計です。

        つまり、
        PROMPT_00_BASELINE.md = 仕様書（詳細）
        AGENTS.md = 現場ルール（短く強制）
        の関係にすると、運用が破綻しません。

        ※さらに個人の全リポジトリ共通ルールが欲しいなら ~/.codex/AGENTS.md も使えます（グローバル既定）。

    ### 2) どうやって「最終版Baseline」を使うのか（実務運用）
        パターン1：AGENTS.mdで常時適用（最もおすすめ）

        最終版Baseline（全文）を prompts/PROMPT_00_BASELINE.md に保存
        その要点（禁止事項・品質・出力形式など）を AGENTS.md に要約して保存
        以後は、Codexに普通に依頼するだけで AGENTS.md のルールが効きやすい構成になります
        パターン2：VSCode内で「@ファイル参照」で毎回読ませる（便利）
        Codex IDE拡張は 開いているファイル／選択範囲／@file参照を文脈にできるので、Baseline全文を毎回貼らなくても運用できます。

        例（VSCodeのCodex入力欄）：
        @prompts/PROMPT_00_BASELINE.md を必ず前提として守ってください。
        不明点は推測で埋めず「要確認」で止めてください。
        次に @prompts/PROMPT_01_SCOPE.md のテンプレに沿ってスコープ定義を作ってください。

    ### 3) 最終版Baselineの保存手順（具体的に）
        手順（そのままやればOK）

        1.AIが出した「最終版Baseline」を 一旦その場で目視レビュー
        ・禁止事項（DB/Webなど）が抜けてないか
        ・出力形式（省略禁止、ファイル単位）が書かれてるか
        ・“推測で埋めない” が書かれてるか

        2.prompts/PROMPT_00_BASELINE.md に 貼り付けて上書き保存
        ・ここが正本です（全文を置く）

        3.リポジトリ直下に AGENTS.md を作り、Baseline要点だけをコピーして短縮版を作る
        Codexはリポジトリ内の AGENTS.md を辿って参照する設計です

        4.Gitを使っているなら コミット（超おすすめ）
        Codex公式Quickstartも「作業前後でGitチェックポイントを作ると戻せる」と書いてます。

    ### 4) AGENTS.mdには何を書けばいいか（テンプレ）
        AGENTS.md は 長くすると読まれにくいので、10〜20行くらいが実用ラインです。
        例：
            # AGENTS.md

            ## Working agreements (Baseline summary)

            - Project: Prompt programming workflow (Baseline -> Assetization).
            - Constraints: No DB, no Web, no external API, no network.
            - Language: Java (Bronze-level). Avoid enum/stream/lambda/record/var.
            - Output format: Always file-by-file. No omissions.
            - Quality: Validate inputs. Do not crash on invalid input; ask again.
            - If requirements are unclear: stop and write "要確認" instead of guessing.
            - Detailed baseline: see prompts/PROMPT_00_BASELINE.md

        Codexはディレクトリ階層に沿って AGENTS.md を探して適用する仕組みがあり、必要ならより深い階層に置いて局所ルールも作れます。

    ### 5) 「Baselineが長くて毎回扱いづらい」問題の解決策
        解決策A：AGENTS.mdに要約、PROMPT_00は詳細に分離（推奨）
        上で説明した方式です。最終的にこれが一番強いです。

        解決策B：カスタムプロンプト化して“呼び出し”にする（個人向け）
        Codexは **Markdownをカスタムプロンプト（スラッシュコマンド相当）**にでき、~/.codex に置く方式があります。ただしこれは **個人環境に閉じる（リポジトリ共有しない）**性質です。

        まとめ

        **最終版Baselineは「設定の正本」**として prompts/PROMPT_00_BASELINE.md に保存します。
        Codexに効かせるための要約を AGENTS.md に置くのが実務で一番安定します。
        VSCodeでは必要に応じて @prompts/PROMPT_00_BASELINE.md を参照して、毎回貼らずに運用できます。

---

## 2.続けて PROMPT_01_SCOPE.md → PROMPT_02_REQUIREMENTS.md → PROMPT_03_ASSUMPTIONS.md → PROMPT_04_DESIGN.md
    各工程の結果は “成果物（決定事項）”としてファイルに保存し、次工程の入力として参照します。

    ### 1)結果の扱い方の基本ルール
        ルール1：工程の出力は「その工程の確定版ドキュメント」として保存する
        ・PROMPT_01 の結果 → スコープ定義（確定版）
        ・PROMPT_02 の結果 → 要件定義（確定版）
        ・PROMPT_03 の結果 → 仮定・未決定（確定版）
        ・PROMPT_04 の結果 → 設計（確定版）

        ルール2：次工程では「前工程の確定版」を入力として渡す
        ・PROMPT_02 は PROMPT_01 の結果を前提にする
        ・PROMPT_03 は PROMPT_02 の結果を前提にする
        ・PROMPT_04 は PROMPT_02 + PROMPT_03 の結果を前提にする

        ルール3：「要確認」が残ったまま次工程へ進まない
        要確認が出たら、その場で 解消 or 明示的に仮定として固定してから進む
        （要確認を放置して設計に入ると、後で手戻りが増えます）

    ### 2)保存場所（VSCodeプロジェクト内）

        テンプレは prompts/、結果は docs/（または prompts/results/）に分けるのが楽です。

        パターンA（おすすめ：テンプレと成果物を分離）
            your-project/
                prompts/                # テンプレ（穴埋め用）
                    PROMPT_00_BASELINE.md
                    PROMPT_01_SCOPE.md
                    PROMPT_02_REQUIREMENTS.md
                    PROMPT_03_ASSUMPTIONS.md
                    PROMPT_04_DESIGN.md

                docs/                   # 確定した成果物（AI出力を保存）
                    00_BASELINE_FINAL.md
                    01_SCOPE_FINAL.md
                    02_REQUIREMENTS_FINAL.md
                    03_ASSUMPTIONS_FINAL.md
                    04_DESIGN_FINAL.md

                README.md
                CHANGELOG.md
                src/

        ・prompts/ は「指示文テンプレ」なので基本いじらない
        ・docs/ は「確定版成果物」なのでここを正本にする

    ### 3)各工程の「実務的な」回し方（手順）
            1) PROMPT_01_SCOPE を実行したら
                1.Codex出力のうち、**「スコープ定義（最終版）」**をコピー
                2.docs/01_SCOPE_FINAL.md に貼って保存
                3.出力に「要確認」があれば、この時点で解消
                    ・追加プロンプトで詰めるか
                    ・次の工程に影響しないなら「仮定」としてPROMPT_03で固定する
                次工程（PROMPT_02）に渡すもの
                    ・docs/01_SCOPE_FINAL.md

            2) PROMPT_02_REQUIREMENTS を実行したら
                1.**「要件定義（FR/NFR/入出力仕様/受入条件）」**をコピー
                2.docs/02_REQUIREMENTS_FINAL.md に保存
                3.受入条件が「テスト可能な文」になってるかだけチェック
                    ・NG例：「適切に表示する」
                    ・OK例：「不正入力時はエラーメッセージを表示し、再入力を促す」
                次工程（PROMPT_03）に渡すもの
                    ・docs/02_REQUIREMENTS_FINAL.md

            3) PROMPT_03_ASSUMPTIONS を実行したら
                1.**「採用する仮定（最終版）」**と「未決定事項」を保存
                2.docs/03_ASSUMPTIONS_FINAL.md に保存
                3.未決定事項が残るなら、ここで決め切る（おすすめ）
                    ・決め切れないなら「この未決定は設計に影響する/しない」を明記しておく
                    （影響するのに放置すると設計が壊れます）
                次工程（PROMPT_04）に渡すもの
                    ・docs/02_REQUIREMENTS_FINAL.md
                    ・docs/03_ASSUMPTIONS_FINAL.md

            4) PROMPT_04_DESIGN を実行したら
                1.**設計（クラス構成・責務・主要メソッド・データ構造・処理フロー）**を保存
                2.docs/04_DESIGN_FINAL.md に保存
                3.「要件→設計対応チェック」があるか確認
                    ・要件にあるのに設計に出てこない機能があれば、ここで直す
                    （実装に入ってから直すと二度手間）
                次工程（PROMPT_05）に渡すもの
                    ・docs/04_DESIGN_FINAL.md

        ###4)次工程に渡すときの具体的な入力方法（VSCode/Codex）
            方法A（確実）：前工程の結果をプロンプトに貼る

            例：PROMPT_02 を実行するとき
                以下は確定したスコープです。
                ---ここから---
                （docs/01_SCOPE_FINAL.md の中身を貼る）
                ---ここまで---

                このスコープに従って要件定義を作ってください。
                不明点は推測で埋めず要確認にしてください。

            方法B（便利）：ファイル参照できる拡張なら参照する

                拡張が対応しているなら、docs/01_SCOPE_FINAL.md を参照して進めます。
                （参照方法は拡張機能ごとに違うので、あなたの環境の作法に合わせます）

---

##3.PROMPT_05_IMPLEMENTATION.md でコード一式を出させます

    前提：PROMPT_05を叩く前に揃っているべきもの

    最低限、これが「確定版」として保存されている状態が理想です。

    ・docs/00_BASELINE_FINAL.md（または prompts/PROMPT_00_BASELINE.md の最終版）
    ・docs/04_DESIGN_FINAL.md（設計確定版：クラス、責務、主要メソッド、データ構造、処理フロー）

    実装生成は 設計が正本です。
    設計が曖昧なまま実装に入ると、出てきたコードの責任が全部あなたに降ってきます。


    作業の流れ（PROMPT_05_IMPLEMENTATION）
       
        ### STEP 0：プロジェクト側の準備（VSCode）
            1.プロジェクトをVSCodeで開く
            2.次を作っておく（空でOK）
                ・src/（Javaなら src/ か src/main/java/）
                ・docs/（確定版の保管）
                ・prompts/（テンプレ保管）

            おすすめ例：
                your-project/
                src/
                docs/
                prompts/

        ### STEP 1：Codexに渡す「入力セット」を作る
            PROMPT_05で渡すべき情報は、基本的にこの3点です。
            1.Baseline（守るルール）
            2.Design（今回の設計確定版）
            3.出力条件（ファイル単位で省略なし、など）
            
            実務的にはこうする
            ・プロンプト欄に 全部貼る（一番確実）
                ・長い場合は「Baselineは要点だけ」＋「Designは全文」でもOK
            
            例：PROMPT_05入力の骨格（コピペ用）
                
                """text
                【基本ルール（要点）】
                - DB/Web/外部API/ネットワーク禁止
                - Java Bronze範囲（enum/stream/lambda/record/var禁止）
                - 出力はファイル単位「ファイル名→コード全文」、省略禁止
                - 入力バリデーション必須、例外で落とさない

                【設計（確定版）】
                ---ここから---
                （docs/04_DESIGN_FINAL.md の内容を貼る）
                ---ここまで---

                【実装生成の指示】
                1) 最初にファイル構成を提示
                2) 次に各ファイルを「ファイル名→コード全文」で順に出す（省略禁止）
                3) 最後にコンパイル/実行手順を書く

        ### STEP 2：Codexに「分割出力」を前提に依頼する（ここ重要）
            コード一式は長くなりがちなので、最初からこう指示するのが安定します。

            推奨の出力方式（事故が少ない）
            ・まず：ファイル構成だけ
            ・次に：1ファイルずつコード全文

            例：最初の依頼（ファイル構成だけ）
                """text
                上記の設計に従い、まずファイル構成だけ提示してください。
                その後、私が「OK」と言ったら1ファイルずつコード全文を出してください。


            こうすると、
            ・いきなり大量出力で途中欠落
            ・途中で設計と違う構成になる
            　を事前に潰せます。

        ### STEP 3：ファイル構成を受け取ったら、VSCode側に“空ファイル”を作る

            ファイル構成が出たら、VSCodeでそのファイルを作ります（中身は空でOK）。

            例：
            ・src/Main.java
            ・src/RpsGame.java
            ・src/RpsJudge.java
            ・src/Stats.java

        ### STEP 4：1ファイルずつコードを受け取り、貼り付けて保存

            Codexにこう返します。

            """text
            OK。まず Main.java をコード全文で出してください。

            出てきたら：

            1.VSCodeで Main.java を開く
            2.全文を貼り付け
            3.保存（Ctrl+S）
            4.次を依頼

            """text
            次に RpsGame.java をコード全文で出してください。

            これを繰り返します。
                1ファイルずつにする理由：
                コピペミスが減る、欠落が減る、レビューしやすい、失敗しても戻せる。

        ### STEP 5：生成物チェック（コンパイル前の最低確認）
            
            全部貼り終わったら、最低限これだけ確認します。
            ・クラス名とファイル名が一致してるか
            ・public class が複数ファイルに散っているか（同名重複してないか）
            ・package 宣言が揃ってるか（使うなら統一）

        ### STEP 6：コンパイル＆実行（VSCodeのターミナル）
            
            packageなしの場合（例：srcに置いた）
            
            """bash
            cd src
            javac *.java
            java Main

        ### STEP 7：動かなかったときの流れ（ここが“運用”）
            
            まずやること（人間側）
            ・エラーメッセージをそのままコピーする
            ・どの操作で発生したかを書く（再現手順）

            Codexへの修正依頼（PROMPT_08形式が理想）
                雑に「動かない」ではなく、こうです。
                
                """text
                【不具合】
                - 現象：コンパイルエラー
                - エラー全文：（貼る）
                - 再現：javac *.java

                【変更禁止】
                - 仕様、メニュー構成は変えない
                - DB/Web禁止

                【依頼】
                - 原因と修正方針を先に説明し、差分修正したコードを出してください

        まとめ：PROMPT_05の“現場フロー”

            1.設計（確定版）を用意
            2.PROMPT_05で ファイル構成だけ出させる
            3.VSCodeで空ファイル作る
            4.1ファイルずつコード全文を出させて貼る
            5.コンパイル＆実行
            6.エラーはログ＋再現手順で差分修正依頼


## 4.PROMPT_06_VERIFICATION.md でテストを出させます

    PROMPT_06（Verification）作業フロー
    前提：PROMPT_06を叩く前に揃えるもの

    最低限、これが確定している状態が理想です。

    ・docs/02_REQUIREMENTS_FINAL.md（要件定義・受入条件）
    ・docs/04_DESIGN_FINAL.md（設計：責務分割、主要メソッド）
    ・src/ のコード一式（PROMPT_05で生成したもの）

    テストは「コード」だけ見てもダメで、要件が正本です。
    要件なしのテストは、ほぼ占いです。


    ###STEP 0：VSCode側でテスト格納場所を作る

        テスト成果物もファイルに残します。おすすめは docs/test/。

        例：
        """text
        your-project/
        docs/
            test/
            06_TEST_PLAN.md
            06_TEST_CASES.md
            06_TEST_RESULTS.md

        （最初は 06_TEST_PLAN.md と 06_TEST_CASES.md だけでOK）

    STEP 1：Codexに渡す「入力セット」を作る

        PROMPT_06で必要な入力は3つです。
        1.Baseline（守るルール） ※要点でOK
        2.Requirements（受入条件） ← これが最重要
        3.実装の概要（できればコードも、無理なら構成と要点）

        実務のやり方（確実）
        ・受入条件（Acceptance Criteria）は 必ず貼る
        ・コード全部を貼れない場合は、
            ・ファイル構成
            ・入力仕様
            ・主要な表示文言
            ・judgeロジックの仕様
            だけでも貼る（これで大事故は減ります）

    STEP 2：PROMPT_06の依頼は「出力物を分けて」出させる

        テスト出力は3点セットに分けると運用しやすいです。
        ・テスト観点（何を見てるか）
        ・手動テスト手順（操作→期待結果）
        ・テストケース表（ID、前提、入力、期待結果、備考）

        PROMPT_06入力の骨格（コピペ用）
            
            """text
            【基本ルール（要点）】
            - 推測で埋めない。曖昧な点は「要確認」にする。
            - 出力は省略しない。

            【要件定義（受入条件を含む）】
            ---ここから---
            （docs/02_REQUIREMENTS_FINAL.md を貼る）
            ---ここまで---

            【実装情報】
            - ファイル構成：
            - Main.java
            - RpsGame.java
            - RpsJudge.java
            - Stats.java
            - 入力仕様：メニュー 0/1/2/3、手は g/c/p（大小OK）、不正入力は再入力
            - 5回勝負：5回実施して集計、勝ち越し判定
            - 戦績表示：勝ち/負け/あいこ、勝率（あいこ含む/除外）

            【依頼】
            1) テスト観点一覧
            2) 手動テスト手順（操作→期待結果）
            3) テストケース表（ID、前提、入力、期待結果、備考）を15件以上
            4) 受入条件→テストケース対応チェック（抜けがあれば追加）
            5) 乱数で結果が変わる箇所は、judgeメソッド単体で固定テストできる形でテスト案を出す

    STEP 3：出力を受け取ったら「保存」する（ここからが運用）

        Codex出力は、そのまま保存して正本化します。
        ・テスト観点＋手順 → docs/test/06_TEST_PLAN.md
        ・テストケース表 → docs/test/06_TEST_CASES.md

        以後、テストはこのファイルが基準になります。
        会話ログは捨ててOK（捨てないけど参照しない）。

    STEP 4：自分で最低限の整合チェック（5分でいい）

        テストがズレてないか、ここだけ確認します。

        チェック項目（最低限）
        ・受入条件の各項目が、テストケース表に最低1つは対応しているか
        ・異常系が入っているか
            ・メニューに文字入力
            ・手入力に x など不正値
            ・空入力
        ・表示系が含まれるか
            ・結果表示（あなた/CPUの手、勝敗）
            ・戦績表示（勝率2種）

        ズレがあったら次のSTEPへ。

        STEP 5：ズレがあったら「テストを修正させる」プロンプトを出す

            ここで雑に「直して」じゃなく、追加・修正指示でいきます。

            例：
            """text
            テストケースに以下が不足しています。

            - 受入条件「大文字入力（G/C/P）も許可」のケースがない
            - 5回勝負で「あいこを含めても5回実施する」確認ケースがない

            上記2点を追加したテストケース表を再出力してください。
            既存のIDは維持し、追加分は末尾に追記してください。

        STEP 6：実際にテストを実行し、結果を残す（超重要）

            PROMPT_06で作ったテストは、実行して初めて価値があります。

            実行ログの残し方（簡単でOK）

                """text
                docs/test/06_TEST_RESULTS.md を作って、以下の形で残します。

                # テスト結果

                ## 実行環境
                - OS:
                - Java:
                - 実行日:

                ## 結果サマリ
                - 実施: 15件
                - OK: 14件
                - NG: 1件

                ## NG詳細
                - TC-12: 不正入力時に再入力にならず終了してしまう
                - 再現手順: ...
                - 期待結果: ...
                - 実際: ...

        STEP 7：NGが出たらPROMPT_08（変更管理）へ送る

            テストNGは、PROMPT_08で直すのが王道です。
            ・現象
            ・再現手順
            ・期待結果
            ・実際結果
            ・変更禁止事項
            ・対象コード

            これで「直したら別のところ壊れた」が激減します。


        まとめ：PROMPT_06の現場フロー

            1.要件（受入条件）とコードを用意
            2.PROMPT_06で
            ・観点
            ・手順
            ・ケース表
            ・受入条件→対応チェック
            　を出させる
            3.docs/test/ に保存して正本化
            4.5分だけ整合チェック
            5.足りないところは追加指示で修正
            6.実行して 06_TEST_RESULTS.md に記録
            7.NGはPROMPT_08で差分修正へ


##5.必要なら PROMPT_07_REVIEW.md → PROMPT_08_CHANGE_CONTROL.md で改修します

    PROMPT_07 → PROMPT_08 改修フロー（作業の流れ）
        前提：改修に入る前に揃えるもの

        最低限これを手元に用意します。

        ・docs/02_REQUIREMENTS_FINAL.md（要件・受入条件）
        ・docs/04_DESIGN_FINAL.md（設計）
        ・src/ の現行コード一式
        ・docs/test/06_TEST_RESULTS.md（テスト結果があれば強い）

        改修は「気分」ではなく「根拠（要件/テスト/現象）」で動かします。


    全体像（結論）

        1.PROMPT_07_REVIEW.mdで
        ・仕様ズレ
        ・バグの原因候補
        ・改善点（優先度付き）
        ・Change Request（変更指示ドラフト）
        　を出させる
        2.人間が 採用する変更だけを確定する（やらない変更も決める）
        3.PROMPT_08_CHANGE_CONTROL.mdで
        ・差分
        ・理由
        ・影響範囲
        ・再テスト
        　をセットで改修させる
        4.VSCodeでコード反映 → 実行 → 再テスト
        5.結果を CHANGELOG.md と 06_TEST_RESULTS.md に残す

    STEP別のやり方

        STEP 1：PROMPT_07（レビュー）を実行する

            目的
            ・「何を直すべきか」を整理し、修正指示の材料を作る工程です。
            ・ここでは まだコードを直させないのがポイント（先に論点を揃える）。

            入力（Codexへ渡すもの）
            ・要件：docs/02_REQUIREMENTS_FINAL.md
            ・設計：docs/04_DESIGN_FINAL.md
            ・現行コード：src/（全文が無理なら対象ファイル）
            ・テスト結果：NGがあれば必ず貼る（エラー文、再現手順）

            出力（欲しいもの）
            ・指摘一覧（優先度：高/中/低）
            ・修正方針（どう直すか）
            ・Change Requestドラフト（このあとPROMPT_08で使う）

            ここで人間がやること（超重要）
            ・指摘を全部やらない。採用する変更だけ選ぶ
                ・例：高だけやる／今回リリースはバグ修正のみ、など
            ・「触るなリスト」も決める
                ・メニュー仕様は維持、など

        STEP 2：Change Request（変更指示）を確定する

            PROMPT_07のドラフトを、そのままPROMPT_08に投げるのは半分正解で半分危険です。
            あなたが最終決定して、変更指示を確定させます。

            Change Requestに必ず入れる項目
            ・変更目的（なぜ）
            ・変更内容（Before/After）
            ・変更対象ファイル
            ・変更禁止事項（触るな）
            ・期待する挙動（受入条件）
            ・再テスト項目

        STEP 3：PROMPT_08（Change Control）で改修を実行させる
            目的
            ・「差分」「理由」「影響」「再テスト」をセットにして安全に修正させます。

            入力（Codexへ渡すもの）
            ・確定したChange Request
            ・現行コード（対象ファイルの全文）
            ・必要なら要件の該当箇所（受入条件）
            出力（受け取るもの）
            ・修正計画（短く）
            ・修正版コード（ファイル単位）
            ・変更理由 / 影響範囲 / 再テスト項目
            ・要確認（あれば）

        STEP 4：VSCodeに反映（1ファイルずつが安全）

            1.変更対象ファイルを開く
            2.修正版コードを貼り付け
            3.保存
            4.コンパイル＆実行

            まとめて全部貼るより、変更したファイルだけ貼る方がミスが減ります。

        STEP 5：再テスト（PROMPT_06で作ったテストが活きる）

            ・docs/test/06_TEST_CASES.md の該当ケースを再実行
            ・NGが解消したか確認
            ・影響範囲のケースも実行（改修で壊れやすい場所）

            結果は docs/test/06_TEST_RESULTS.md に追記します。

        STEP 6：変更履歴を残す（資産化）

            最後に必ず残します。

            CHANGELOG.md に最低限書く
            ・変更内容
            ・変更理由
            ・影響範囲
            ・再テスト結果

        実務で一番多いパターン別フロー

            パターンA：バグ修正（最優先で回す）
            ・PROMPT_07：NG原因の推測＋修正案
            ・PROMPT_08：差分修正
            ・再テスト
            ・CHANGELOG更新

            パターンB：仕様追加（機能拡張）
            ・PROMPT_02に追記（要件更新）
            ・PROMPT_03で仮定更新
            ・PROMPT_04で設計更新
            ・PROMPT_08で改修（※PROMPT_05をやり直さない）
            ・PROMPT_06でテスト追加

            仕様追加は レビュー→変更だけで済ませず、要件と設計を先に更新すると破綻しません。

        まとめ（この順で回せばOK）

            ・PROMPT_07：直すべき点を整理して Change Request を作る
            ・人間が採用変更を確定（やる/やらないを決める）
            ・PROMPT_08：差分・理由・影響・再テストで改修させる
            ・VSCodeで反映 → 再テスト → CHANGELOG更新


##6.最後に PROMPT_09_ASSETIZATION.md で README/CHANGELOG まで固めます

    会話と途中成果物を、再現可能な“プロジェクト資産”に変換する作業

    PROMPT_09（Assetization）作業フロー

        前提：PROMPT_09を叩く前に揃えるもの

            最低限これが揃っているのが理想です（全部揃ってなくても進められるが、品質が落ちます）。

            ・docs/00_BASELINE_FINAL.md（または prompts/PROMPT_00_BASELINE.md の最終版）
            ・docs/01_SCOPE_FINAL.md
            ・docs/02_REQUIREMENTS_FINAL.md
            ・docs/03_ASSUMPTIONS_FINAL.md
            ・docs/04_DESIGN_FINAL.md

            src/ のコード一式

            ・docs/test/06_TEST_PLAN.md（または 06_VERIFICATION の出力）
            ・docs/test/06_TEST_CASES.md
            ・docs/test/06_TEST_RESULTS.md（実行したなら）
            ・CHANGELOG.md（すでにあるなら、現状）
            ・変更があれば：PROMPT_08の出力（差分、理由、影響、再テスト）

            Assetizationは「情報を集める工程」ではなく、
            **集まった情報を“整形して固定する工程”**です。

        STEP 0：VSCode側で保存先を決める（先に固定）

            おすすめの保存先はこの2つ。

            ・README.md（プロジェクト直下）
            ・CHANGELOG.md（プロジェクト直下）

            補助として、docs/ に “確定版ドキュメント” を残します。

        STEP 1：Codexに渡す「入力セット」を準備する

            PROMPT_09に渡すべき入力は、ざっくり次の3カテゴリです。

                ① 仕様の正本（要件とルール）
                ・Baseline（禁止事項、品質基準、出力形式）
                ・Scope（in/out, Done）
                ・Requirements（FR/NFR、受入条件）
                ・Assumptions（仮定、未決定）

                ② 実装の正本
                ・コード一式（全部貼れないなら「ファイル構成＋主要クラス＋実行方法」でも可）

                ③ 検証の正本
                ・テスト観点・ケース
                ・実行結果（やったなら）

        STEP 2：PROMPT_09の依頼は「出力を分割」させる（現場のコツ）

            いきなり全部を一発生成させると、長すぎて欠けやすいです。
            なので、PROMPT_09は 3段階出力が安全です。

            段階A：README案を生成
            ・READMEだけ先に作らせる

            段階B：CHANGELOG案を生成
            ・CHANGELOGだけ作らせる（変更がないなら初版だけ）

            段階C：資産化インデックス（保存すべきファイル一覧＋再開手順）
            ・「次回どう再開するか」まで作る


        STEP 3：PROMPT_09の実行（コピペ骨格）

            この形で叩くと安定します。

            """text
            【基本ルール（要点）】
            - DB/Web/外部API/ネットワーク禁止
            - Java Bronze範囲
            - 推測で埋めない。曖昧なら「要確認」

            【スコープ確定版】
            ---ここから---
            （docs/01_SCOPE_FINAL.md を貼る）
            ---ここまで---

            【要件定義確定版】
            ---ここから---
            （docs/02_REQUIREMENTS_FINAL.md を貼る）
            ---ここまで---

            【仮定確定版】
            ---ここから---
            （docs/03_ASSUMPTIONS_FINAL.md を貼る）
            ---ここまで---

            【設計確定版】
            ---ここから---
            （docs/04_DESIGN_FINAL.md を貼る）
            ---ここまで---

            【実装情報】
            - ファイル構成：（貼る）
            - 実行方法：（貼る）
            - 主要クラス概要：（貼る）

            【テスト情報】
            ---ここから---
            （docs/test/06_TEST_PLAN.md と 06_TEST_CASES.md の要点、結果があれば 06_TEST_RESULTS.md）
            ---ここまで---

            【依頼】
            1) README.md を生成してください（概要/実行方法/仕様/入力/制約/テスト方法を含める）
            2) CHANGELOG.md を生成してください（変更がなければ初版として作る）
            3) 最後に「次回再開手順」と「保存ファイル一覧」を出してください

            出力は3セクションに分けてください：
            - README.md
            - CHANGELOG.md
            - 再開手順・保存一覧

        STEP 4：出力をVSCodeに保存（ここから“固定化”）

            Codexから出た内容を、それぞれファイルに貼ります。
            ・README部分 → README.md
            ・CHANGELOG部分 → CHANGELOG.md
            ・再開手順・保存一覧 → docs/ASSETIZATION_NOTES.md（おすすめ）

            保存しておくと強い補助ファイル：
            ・docs/ASSETIZATION_NOTES.md（再開手順・構成一覧・決定事項まとめ）

        STEP 5：最低限の目視チェック（5分でOK）

            README/CHANGELOGが使い物になるか、ここだけ確認します。

            READMEチェック
            ・実行方法が書いてある（コマンド or VSCode手順）
            ・メニュー仕様が書いてある（0/1/2/3）
            ・入力仕様が書いてある（g/c/p、大文字OK、不正入力は再入力）
            ・禁止事項（DB/Webなし）が書いてある

            CHANGELOGチェック
            ・変更があるなら「理由」「影響範囲」「再テスト」が書いてある
            ・変更がないなら「初版」として成立している

            ズレがあれば、PROMPT_09に「ここ直して」で再生成させます。
            （この工程の良いところは、コードを触らずに直せる点）

        STEP 6：Gitでコミット（推奨）

            README/CHANGELOG更新は、必ずコミットしておくのが強いです。

            例：
            ・docs: add README and CHANGELOG
            ・docs: update assetization notes


        よくある落とし穴と回避策

            落とし穴1：READMEが「説明不足」になる
            → 回避：READMEのセクションを固定する（下にテンプレあり）

            落とし穴2：CHANGELOGが「何をしたか」だけで終わる
            → 回避：「理由」「影響」「再テスト」を必須にする

            落とし穴3：Assetizationが一発出力で途中欠ける
            → 回避：README→CHANGELOG→再開手順の3段階で出させる

        READMEの標準構成（参考テンプレ）

            概要
            ・実行方法
            ・機能（メニュー説明）
            ・入力仕様
            ・仕様（勝敗判定、戦績、勝率）
            ・制約（DB/Webなし等）
            ・テスト方法
            ・既知の制限 / 今後の改善

            まとめ：PROMPT_09の作業フロー
            1.前工程の確定版（要件/設計/テスト/コード）を揃える
            2.PROMPT_09で README → CHANGELOG → 再開手順の順に生成させる
            3.VSCodeで README.md と CHANGELOG.md に保存して正本化
            4.5分だけ目視チェックしてズレを直す
            5.Gitコミットして完了