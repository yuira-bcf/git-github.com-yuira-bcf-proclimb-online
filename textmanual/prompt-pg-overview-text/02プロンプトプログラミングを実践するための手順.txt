# プロンプトプログラミングを進める手順（再確認・ブラッシュアップ版）

## 0. この手順が狙うこと
この手順は、プロンプトプログラミングを「会話で進める」から一段引き上げて、  
**再現性・品質・変更耐性がある“開発プロセス”として運用する**ことを目的に整理しています。

前回の流れに大きな誤りはありませんでしたが、次の点を補強してブラッシュアップしました。

- 各フェーズで **入力 / 出力（成果物）/ 合格条件** を明確化
- 仕様の抜け・曖昧さを **仮定として固定**する工程を追加
- 「実装 → テスト → 修正」の反復を **変更管理（差分・理由・影響）**として明文化
- プロンプトを **資産として保存する単位**を整理

---

## 1. 前提（役割分担）を明確にします
プロンプトプログラミングは「AIが全部やる」ではなく、役割が分かれます。

- **人間がすること**
  - 目的・仕様・制約・合格条件を決めます
  - 出力物を読み、妥当性を判断します
  - 実行して動作確認します（※コードを直接編集しない運用でも、実行検証は必須です）
  - 変更要求（差分）を出します

- **AIがすること**
  - 設計案を出します
  - 実装（コード）を生成します
  - テスト観点・テスト手順を作ります
  - 修正案（差分）を出します

ここが曖昧だと「誰が責任を持つか」が崩れます。最初に固定します。

---

## 2. 全体フロー（結論）
プロンプトプログラミングの標準フローは次の順で回します。

1. **基本ルール固定（Baseline）**
2. **目的・範囲の確定（Scope）**
3. **要件定義（Requirements）**
4. **仮定と未決定事項の固定（Assumptions）**
5. **設計（Design）**
6. **実装生成（Implementation）**
7. **検証（Verification）**
8. **レビューと改善（Review）**
9. **変更管理しながら反復（Change Control）**
10. **資産化（Assetization）**

重要なのは、  
**「いきなり実装」ではなく、要件→設計→実装→検証の順を守る**ことです。  
順番を飛ばすと、出力がブレて修正コストが爆増します（AIが悪いのではなく、人間の指示が曖昧なままになるからです）。

---

## 3. 各フェーズの手順（入力・出力・合格条件つき）

### Phase 1：基本ルール固定（Baseline）
**目的**：以降ずっと適用する“変えない前提”を固定します。  
**入力**：技術制約、禁止事項、出力形式、品質基準  
**出力（成果物）**：基本ルールプロンプト（1枚）  
**合格条件**：矛盾がない／禁止事項が明確／出力形式が固定

**最低限入れる項目**
- 禁止：DB、Web、外部API、ネットワーク通信（必要に応じて）
- 使用言語と範囲：例）Java Bronze範囲
- 出力形式：ファイル単位、コード全文、命名規約
- 品質：入力バリデーション、例外で落とさない、ログ方針

---

### Phase 2：目的・範囲の確定（Scope）
**目的**：何を作り、何を作らないかを決めます。  
**入力**：目的、想定ユーザー、実行形態（コンソール / GUI）  
**出力**：スコープ定義（in/out）  
**合格条件**：「完成」が何か説明できる／やらないことが書かれている

**ここで決める例**
- in：基本機能、必須の画面・操作
- out：ネット対戦、ランキングサーバ、課金、画像演出など

---

### Phase 3：要件定義（Requirements）
**目的**：AIが迷わないレベルまで振る舞いを文章化します。  
**入力**：機能要件、非機能要件、入力形式、出力形式  
**出力**：要件一覧、受入条件（Acceptance Criteria）  
**合格条件**：テスト観点に落とせる／曖昧語（適切に、いい感じに）が減っている

**必ず入れると事故が減る項目**
- 入力の許容範囲（例：g/c/p のみ、大小文字は許可）
- 不正入力時の動き（再入力、エラーメッセージ）
- データ保持（メモリのみ or ファイル保存）
- メニュー操作や終了条件

---

### Phase 4：仮定と未決定事項の固定（Assumptions）
**目的**：仕様の空白をAIが勝手に埋めてブレるのを防ぎます。  
**入力**：決まっていない点、選択肢  
**出力**：仮定リスト（Assumptions）＋未決定リスト（Open Issues）  
**合格条件**：AIが推測で決める余地が減っている

**例**
- 仮定：勝率は「あいこ含む」「あいこ除外」の両方を表示する
- 未決定：ファイル保存形式はCSVにするかJSONにするか

---

### Phase 5：設計（Design）
**目的**：コードの前に構造を固めます。  
**入力**：要件＋仮定  
**出力**：クラス構成、責務、主要メソッド、データ構造、処理フロー  
**合格条件**：人間が読んで理解できる／要件が設計に対応している（抜けがない）

**よくあるミス**
- Mainに全部詰め込み（修正が地獄になります）
- 仕様が未確定のまま設計（後で崩壊します）

---

### Phase 6：実装生成（Implementation）
**目的**：設計に従ってコードを生成します。  
**入力**：設計、出力形式ルール、禁止事項  
**出力**：ファイル単位のソースコード一式  
**合格条件**：コンパイルが通る前提になっている／依存関係が破綻していない

**実装生成時の指示に入れると強い項目**
- 「ファイル名 → コード全文」の形式で出す
- 実行手順（コマンド）も併記する
- エラー処理方針（再入力、例外握り潰し禁止など）

---

### Phase 7：検証（Verification）
**目的**：期待動作を満たすかを確認できる形にします。  
**入力**：要件、コード  
**出力**：テスト観点、手動テスト手順、テストケース表  
**合格条件**：受入条件を網羅する／異常系が含まれる

**補足**
- ここは「AIにテストを書かせる」だけでも価値があります。
- 実行して確かめるのは人間の仕事です（AIは実行環境を持たない前提が多いので、ここを誤解すると詰みます）。

---

### Phase 8：レビューと改善（Review）
**目的**：品質の穴（例外、境界値、保守性）を潰します。  
**入力**：コード、テスト結果、気づき  
**出力**：改善提案、リスク、修正方針  
**合格条件**：修正対象が具体化されている／修正後の期待動作が書かれている

**レビュー観点（最低限）**
- 入力バリデーションは十分か
- 例外で落ちないか
- 仕様と表示文言が一致しているか
- 変更しやすい構造か（責務分離）

---

### Phase 9：変更管理しながら反復（Change Control）
**目的**：「直して」を卒業して、差分管理で品質を上げます。  
**入力**：変更要求（何を/なぜ/どこまで）  
**出力**：差分修正、変更理由、影響範囲、再テスト項目  
**合格条件**：変更理由が説明され、影響範囲が明記されている

**変更要求テンプレ（これだけで事故が減ります）**
- 変更目的：
- 変更内容（Before/After）：
- 変更禁止事項（触るなリスト）：
- 受入条件（再テスト）：

---

### Phase 10：資産化（Assetization）
**目的**：会話を“開発資産”に変えます。  
**入力**：各フェーズのプロンプト、成果物  
**出力**：プロンプト・成果物・変更履歴の保存  
**合格条件**：別の人でも再現できる状態になっている

**推奨の保存単位**
- `PROMPT_00_BASELINE.md`
- `PROMPT_01_SCOPE.md`
- `PROMPT_02_REQUIREMENTS.md`
- `PROMPT_03_ASSUMPTIONS.md`
- `PROMPT_04_DESIGN.md`
- `PROMPT_05_IMPLEMENTATION.md`
- `PROMPT_06_TEST.md`
- `PROMPT_07_REVIEW.md`
- `PROMPT_08_CHANGELOG.md`

---

## 4. ミスが起きやすいポイント（先回りチェック）
プロンプトプログラミングでよく起きる失敗はだいたい次の4つです。

1. **要件が曖昧なまま実装に入る**  
2. **仮定を固定せず、AIが推測で埋める**  
3. **修正指示が雑で、別の場所が壊れる**  
4. **プロンプトを保存せず、再現できない**

上のフローは、これらを潰すように作っています。

---

## 5. まとめ（最短で正しく回すコツ）
- まず **基本ルール**を固定します  
- 次に **要件**を文章で確定します  
- **仮定**を明示してブレを潰します  
- **設計 → 実装 → 検証**の順を守ります  
- 修正は **差分・理由・影響範囲**で回します  
- 最後に **プロンプトを資産化**します  

この運用ができると、プロンプトプログラミングは「速い」だけでなく  
**壊れにくく、引き継げる開発手法**になります。
